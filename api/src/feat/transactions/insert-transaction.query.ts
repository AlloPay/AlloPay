// GENERATED by @edgedb/generate v0.5.3

import type {Executor} from "edgedb";

export type InsertTransactionArgs = {
  readonly "hash": string;
  readonly "account": string;
  readonly "policy": string;
  readonly "validationErrors": ReadonlyArray<{
  readonly "reason": string;
  readonly "operation": number;
}>;
  readonly "label"?: string | null;
  readonly "icon"?: string | null;
  readonly "timestamp": Date;
  readonly "dapp"?: {
    readonly "name": string;
    readonly "url": string;
    readonly "icons": ReadonlyArray<string>;
  } | null;
  readonly "operations": ReadonlyArray<unknown>;
  readonly "gasLimit": bigint;
  readonly "feeToken": string;
  readonly "maxAmount": string;
  readonly "paymaster": string;
  readonly "activationFee": string;
};

export type InsertTransactionReturns = {
  "id": string;
};

export function insertTransaction(client: Executor, args: InsertTransactionArgs): Promise<InsertTransactionReturns> {
  return client.queryRequiredSingle(`\
insert Transaction {
  hash := <Bytes32>$hash,
  account := (select Account filter .address = <UAddress>$account),
  policy := (<Policy>(<uuid>$policy)),
  validationErrors := <array<tuple<reason: str, operation: int32>>>$validationErrors,
  label := <optional BoundedStr>$label,
  icon := <optional Url>$icon,
  timestamp := <datetime>$timestamp,
  dapp := <optional tuple<name: str, url: Url, icons: array<Url>>>$dapp,
  unorderedOperations := (
    for pair in enumerate(array_unpack(<array<json>>$operations)) union (
      insert Operation {
        to := <Address>pair.1['to'],
        value := <uint256>json_get(pair.1, 'value'),
        data := <Bytes>json_get(pair.1, 'data'),
        position := <uint16>pair.0
      }
    )
  ),
  gasLimit := <uint256>$gasLimit,
  feeToken := (select token(<UAddress>$feeToken)),
  maxAmount := <decimal>$maxAmount,
  paymaster := <Address>$paymaster,
  paymasterEthFees := (
    insert PaymasterFees {
      activation := <decimal>$activationFee,
    }
  )
}`, args);

}
