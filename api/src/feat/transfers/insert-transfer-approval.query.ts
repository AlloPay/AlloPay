// GENERATED by @edgedb/generate v0.5.4

import type {Executor} from "edgedb";

export type InsertTransferApprovalArgs = {
  readonly "account": string;
  readonly "result"?: string | null;
  readonly "from": string;
  readonly "to": string;
  readonly "systxHash"?: string | null;
  readonly "block": bigint;
  readonly "logIndex": number;
  readonly "timestamp": Date;
  readonly "token": string;
  readonly "amount": string;
};

export type InsertTransferApprovalReturns = {
  "id": string;
} | null;

export function insertTransferApproval(client: Executor, args: InsertTransferApprovalArgs): Promise<InsertTransferApprovalReturns> {
  return client.querySingle(`\
with accountAddress := <UAddress>$account,
     localAccount := as_address(accountAddress),
     account := (select Account filter .address = accountAddress),
     resultId := <optional uuid>$result,
     result := assert_single((select Result filter .id = resultId and .transaction.account = account) if exists resultId else {}),
     from := <Address>$from,
     to := <Address>$to,
     transfer := (
       insert TransferApproval {
         account := account,
         systxHash := <optional Bytes32>$systxHash,
         result := result,
         block := <bigint>$block,
         logIndex := <uint32>$logIndex,
         timestamp := <datetime>$timestamp,
         confirmed := (result is Confirmed ?? true),
         from := from,
         to := to,
         tokenAddress := <UAddress>$token,
         amount := <decimal>$amount,
         incoming := (to = localAccount),
         outgoing := (from = localAccount),
         fee := ((result.transaction.paymaster in {from, to}) ?? false)
       } unless conflict
     )
select transfer;`, args);

}
