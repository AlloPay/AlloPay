datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}

generator nestgraphql {
  provider = "prisma-nestjs-graphql"
  output   = "../generated"

  noTypeId                        = true
  graphqlScalars_BigInt_name      = "GraphQLBigInt"
  graphqlScalars_BigInt_specifier = "graphql-scalars"
}

model Account {
  id         String  @id @db.Char(42) // address
  impl       String  @db.Char(42) // address
  deploySalt String  @db.Char(66) // bytes32
  name       String
  isActive   Boolean @default(false)

  policies     Policy[]
  policyStates PolicyState[]
  proposals    Proposal[]
  comments     Comment[]
}

////////////////////////////////////////////////////////////////
//                                USER                        //
////////////////////////////////////////////////////////////////

model User {
  id        String  @id @db.Char(42) // address
  name      String?
  /// @HideField()
  pushToken String?

  contacts  Contact[]
  approvals Approval[]
  comments  Comment[]
  reactions Reaction[]
  approvers Approver[]
  proposals Proposal[]
}

model Contact {
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @db.Char(42) // address
  addr   String @db.Char(42) // address
  name   String

  @@id([userId, addr])
  @@unique([userId, name], name: "name_identifier")
}

////////////////////////////////////////////////////////////////
//                               POLICY                       //
////////////////////////////////////////////////////////////////

model Policy {
  account   Account      @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId String       @db.Char(42) // address
  key       BigInt // uint32
  name      String
  active    PolicyState? @relation(name: "active", fields: [activeId], references: [id])
  activeId  BigInt?
  draft     PolicyState? @relation(name: "draft", fields: [draftId], references: [id])
  draftId   BigInt?

  states PolicyState[]

  @@id([accountId, key])
  @@unique([activeId])
  @@unique([draftId])
  @@unique([accountId, name])
}

model PolicyState {
  id         BigInt    @id @default(autoincrement())
  account    Account   @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId  String    @db.Char(42) // address
  policy     Policy    @relation(fields: [accountId, policyKey], references: [accountId, key])
  policyKey  BigInt // uint32
  proposal   Proposal? @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  proposalId String?   @db.Char(66) // bytes32
  createdAt  DateTime  @default(now())
  isRemoved  Boolean   @default(false)

  activeOf  Policy?    @relation(name: "active")
  draftOf   Policy?    @relation(name: "draft")
  approvers Approver[]
  threshold Int        @default(0)
  targets   Target[]

  @@unique([accountId, policyKey, proposalId])
  @@index([accountId, policyKey, createdAt(sort: Desc)], name: "policy_createdAt")
}

model Approver {
  state   PolicyState @relation(fields: [stateId], references: [id], onDelete: Cascade)
  stateId BigInt
  user    User        @relation(fields: [userId], references: [id])
  userId  String      @db.Char(42) // address

  @@id([stateId, userId])
}

model Target {
  state     PolicyState @relation(fields: [stateId], references: [id], onDelete: Cascade)
  stateId   BigInt
  to        String // address | '*'
  selectors String[] // bytes4 | '*'

  @@id([stateId, to])
}

////////////////////////////////////////////////////////////////
//                             TRANSACTION                    //
////////////////////////////////////////////////////////////////

model Proposal {
  id             String      @id @db.Char(66) // hash: bytes32
  account        Account     @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId      String      @db.Char(42) // address
  proposer       User        @relation(fields: [proposerId], references: [id])
  proposerId     String      @db.Char(42) // address
  to             String      @db.Char(42) // address
  value          Decimal?    @db.Decimal(79, 0) // uint256
  data           String? // bytes
  nonce          BigInt // uint256
  gasLimit       BigInt? // uint256
  estimatedOpGas BigInt // uint256
  feeToken       String?     @db.Char(42) // address
  createdAt      DateTime    @default(now())
  simulation     Simulation?

  approvals    Approval[]
  transactions Transaction[]
  policyStates PolicyState[]
}

model Transaction {
  hash String @id @db.Char(66) // bytes32

  proposal   Proposal            @relation(fields: [proposalId], references: [id])
  proposalId String              @db.Char(66) // bytes32
  gasLimit   Decimal             @db.Decimal(19, 0)
  gasPrice   Decimal?            @db.Decimal(19, 0)
  createdAt  DateTime            @default(now())
  receipt    TransactionReceipt?
}

model TransactionReceipt {
  transaction     Transaction @relation(fields: [transactionHash], references: [hash])
  transactionHash String      @id @db.Char(66) // bytes32
  success         Boolean
  response        String? // bytes
  gasUsed         Decimal     @db.Decimal(19, 0)
  gasPrice        Decimal     @db.Decimal(19, 0)
  fee             Decimal     @db.Decimal(79, 0) // uint256
  timestamp       DateTime    @default(now())

  transfers Transfer[]
}

model Transfer {
  id              Int                @id @default(autoincrement())
  receipt         TransactionReceipt @relation(fields: [transactionHash], references: [transactionHash])
  transactionHash String             @db.Char(66) // bytes32
  token           String             @db.Char(42) // address
  from            String             @db.Char(42) // address
  to              String             @db.Char(42) // address
  amount          Decimal            @db.Decimal(79, 0) // uint256
}

model Simulation {
  proposal   Proposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  proposalId String   @id @db.Char(66) // bytes32 @map("id")

  transfers SimulatedTransfer[]
}

model SimulatedTransfer {
  id         Int        @id @default(autoincrement())
  simulation Simulation @relation(fields: [proposalId], references: [proposalId], onDelete: Cascade)
  proposalId String     @db.Char(66) // bytes32 @map("simulationId")
  token      String     @db.Char(42) // address
  from       String     @db.Char(42) // address
  to         String     @db.Char(42) // address
  amount     Decimal    @db.Decimal(79, 0) // uint256
}

model Approval {
  proposal   Proposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  proposalId String   @db.Char(66) // bytes32
  user       User     @relation(fields: [userId], references: [id])
  userId     String   @db.Char(42) // address

  signature String? // bytes; rejected if null
  createdAt DateTime @default(now())

  @@id([proposalId, userId])
}

////////////////////////////////////////////////////////////////
//                               CONTRACT                     //
////////////////////////////////////////////////////////////////

model Contract {
  id String @id @db.Char(42) // address

  functions ContractFunction[]
}

model ContractFunction {
  id         Int       @id @default(autoincrement())
  contract   Contract? @relation(fields: [contractId], references: [id], onDelete: Cascade)
  contractId String?   @db.Char(42) // address
  selector   String    @db.Char(10) // bytes4
  abi        Json
  source     AbiSource

  @@unique([contractId, selector])
  @@index([selector])
}

enum AbiSource {
  VERIFIED
  STANDARD
  DECOMPILED
}

////////////////////////////////////////////////////////////////
//                               COMMENT                      //
////////////////////////////////////////////////////////////////

model Comment {
  id Int @id @default(autoincrement())

  account   Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId String   @db.Char(42) // address
  key       String
  author    User     @relation(fields: [authorId], references: [id])
  authorId  String   @db.Char(42) // address
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()

  reactions Reaction[]

  @@index([accountId, key])
}

model Reaction {
  comment   Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId Int
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String  @db.Char(42) // address

  emojis    String[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()

  @@id([commentId, userId])
}
