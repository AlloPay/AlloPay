datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}

generator nestgraphql {
  provider = "prisma-nestjs-graphql"
  output   = "../generated"
}

model Account {
  id         String  @id @db.Char(42) // address
  impl       String  @db.Char(42) // address
  deploySalt String  @db.Char(66) // bytes32
  name       String
  isActive   Boolean @default(false)

  rules      Rule[]
  ruleStates RuleState[]
  proposals  Proposal[]
  comments   Comment[]
}

////////////////////////////////////////////////////////////////
//                                USER                        //
////////////////////////////////////////////////////////////////

model User {
  id        String  @id @db.Char(42) // address
  name      String?
  /// @HideField()
  pushToken String?

  contacts  Contact[]
  approvals Approval[]
  comments  Comment[]
  reactions Reaction[]
  approvers Approver[]
  proposals Proposal[]
}

model Contact {
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @db.Char(42) // address
  addr   String @db.Char(42) // address
  name   String

  @@id([userId, addr])
  @@unique([userId, name], name: "name_identifier")
}

////////////////////////////////////////////////////////////////
//                                RULE                        //
////////////////////////////////////////////////////////////////

model Rule {
  account   Account    @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId String     @db.Char(42) // address
  key       Int
  name      String
  active    RuleState? @relation(name: "active", fields: [activeId], references: [id], onDelete: Cascade)
  activeId  Int?
  draft     RuleState? @relation(name: "draft", fields: [draftId], references: [id], onDelete: Cascade)
  draftId   Int?

  states RuleState[]

  @@id([accountId, key])
  @@unique([activeId])
  @@unique([draftId])
}

model RuleState {
  id         Int       @id @default(autoincrement())
  account    Account   @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId  String    @db.Char(42) // address
  rule       Rule      @relation(fields: [accountId, ruleKey], references: [accountId, key], onDelete: Cascade)
  ruleKey    Int
  proposal   Proposal? @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  proposalId String?   @db.Char(66) // bytes32
  createdAt  DateTime  @default(now())
  isRemoved  Boolean   @default(false)

  activeStateOf Rule?              @relation(name: "active")
  draftStateOf  Rule?              @relation(name: "draft")
  approvers     Approver[]
  onlyFunctions String[]    @db.Char(10)  // bytes4
  onlyTargets   String[]    @db.Char(66)  // address

  @@unique([accountId, ruleKey, proposalId])
  @@index([accountId, ruleKey, createdAt(sort: Desc)], name: "rule_createdAt")
}

model Approver {
  ruleState   RuleState @relation(fields: [ruleStateId], references: [id], onDelete: Cascade)
  ruleStateId Int
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String    @db.Char(42) // address

  @@id([ruleStateId, userId])
}

////////////////////////////////////////////////////////////////
//                             TRANSACTION                    //
////////////////////////////////////////////////////////////////

model Proposal {
  id         String   @id @db.Char(66) // hash: bytes32
  account    Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId  String   @db.Char(42) // address
  proposer   User     @relation(fields: [proposerId], references: [id])
  proposerId String   @db.Char(42) // address
  to         String   @db.Char(42) // address
  value      String? //@db.Decimal(79, 0) // uint256
  data       String? // bytes
  nonce      Int
  gasLimit   Decimal? @db.Decimal(19, 0)
  createdAt  DateTime @default(now())

  approvals    Approval[]
  transactions Transaction[]
  ruleStates   RuleState[]
}

model Transaction {
  hash String @id @db.Char(66) // bytes32

  proposal   Proposal             @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  proposalId String               @db.Char(66) // bytes32
  gasLimit   Decimal              @db.Decimal(19, 0)
  gasPrice   Decimal?             @db.Decimal(19, 0)
  createdAt  DateTime             @default(now())
  response   TransactionResponse?
}

model TransactionResponse {
  transaction     Transaction @relation(fields: [transactionHash], references: [hash], onDelete: Cascade)
  transactionHash String      @id @db.Char(66) // bytes32

  success   Boolean
  response  String   @db.Char(66) // bytes32
  timestamp DateTime @default(now())
}

model Approval {
  proposal   Proposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  proposalId String   @db.Char(66) // bytes32
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String   @db.Char(42) // address

  signature String? // bytes; rejected if null
  createdAt DateTime @default(now())

  @@id([proposalId, userId])
}

model ContractMethod {
  contract String @default("0x0000000000000000000000000000000000000000") @db.Char(42) // address
  sighash  String @db.Char(10) // bytes4
  fragment Json

  @@id([contract, sighash])
  @@index([sighash])
}

////////////////////////////////////////////////////////////////
//                               COMMENT                      //
////////////////////////////////////////////////////////////////

model Comment {
  id Int @id @default(autoincrement())

  account   Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId String   @db.Char(42) // address
  key       String
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  String   @db.Char(42) // address
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()

  reactions Reaction[]

  @@index([accountId, key])
}

model Reaction {
  comment   Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId Int
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String  @db.Char(42) // address

  emojis    String[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()

  @@id([commentId, userId])
}
