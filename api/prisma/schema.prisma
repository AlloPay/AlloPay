datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}

generator nestgraphql {
  provider = "prisma-nestjs-graphql"
  output   = "../generated"
}

model Account {
  id         String  @id @db.Char(42) // address
  impl       String  @db.Char(42) // address
  deploySalt String  @db.Char(66) // bytes32
  name       String
  isActive   Boolean @default(false)

  policies           Policy[]
  policyRulesHistory PolicyRules[]
  proposals          Proposal[]
  comments           Comment[]
}

////////////////////////////////////////////////////////////////
//                                USER                        //
////////////////////////////////////////////////////////////////

model User {
  id        String  @id @db.Char(42) // address
  name      String?
  /// @HideField()
  pushToken String?

  contacts  Contact[]
  approvals Approval[]
  comments  Comment[]
  reactions Reaction[]
  approvers Approver[]
  proposals Proposal[]
}

model Contact {
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @db.Char(42) // address
  addr   String @db.Char(42) // address
  name   String

  @@id([userId, addr])
  @@unique([userId, name], name: "name_identifier")
}

////////////////////////////////////////////////////////////////
//                               POLICY                       //
////////////////////////////////////////////////////////////////

model Policy {
  account   Account      @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId String       @db.Char(42) // address
  key       BigInt // uint32
  name      String
  active    PolicyRules? @relation(name: "active", fields: [activeId], references: [id])
  activeId  BigInt?
  draft     PolicyRules? @relation(name: "draft", fields: [draftId], references: [id])
  draftId   BigInt?

  rulesHistory PolicyRules[]

  @@id([accountId, key])
  @@unique([activeId])
  @@unique([draftId])
}

model PolicyRules {
  id         BigInt    @id @default(autoincrement())
  account    Account   @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId  String    @db.Char(42) // address
  policy     Policy    @relation(fields: [accountId, policyKey], references: [accountId, key])
  policyKey  BigInt // uint32
  proposal   Proposal? @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  proposalId String?   @db.Char(66) // bytes32
  createdAt  DateTime  @default(now())
  isRemoved  Boolean   @default(false)

  activeRulesOf Policy?    @relation(name: "active")
  draftRulesOf  Policy?    @relation(name: "draft")
  approvers     Approver[]
  onlyFunctions String[]   @db.Char(10) // bytes4
  onlyTargets   String[]   @db.Char(66) // address

  @@unique([accountId, policyKey, proposalId])
  @@index([accountId, policyKey, createdAt(sort: Desc)], name: "policy_createdAt")
}

model Approver {
  policyRules   PolicyRules @relation(fields: [policyRulesId], references: [id], onDelete: Cascade)
  policyRulesId BigInt
  user          User        @relation(fields: [userId], references: [id])
  userId        String      @db.Char(42) // address

  @@id([policyRulesId, userId])
}

////////////////////////////////////////////////////////////////
//                             TRANSACTION                    //
////////////////////////////////////////////////////////////////

model Proposal {
  id         String   @id @db.Char(66) // hash: bytes32
  account    Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId  String   @db.Char(42) // address
  proposer   User     @relation(fields: [proposerId], references: [id])
  proposerId String   @db.Char(42) // address
  to         String   @db.Char(42) // address
  value      Decimal? @db.Decimal(79, 0) // uint256
  data       String? // bytes
  nonce      BigInt
  gasLimit   BigInt?
  createdAt  DateTime @default(now())

  approvals    Approval[]
  transactions Transaction[]
  policyRules  PolicyRules[]
}

model Transaction {
  hash String @id @db.Char(66) // bytes32

  proposal   Proposal             @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  proposalId String               @db.Char(66) // bytes32
  gasLimit   Decimal              @db.Decimal(19, 0)
  gasPrice   Decimal?             @db.Decimal(19, 0)
  createdAt  DateTime             @default(now())
  response   TransactionResponse?
}

model TransactionResponse {
  transaction     Transaction @relation(fields: [transactionHash], references: [hash], onDelete: Cascade)
  transactionHash String      @id @db.Char(66) // bytes32

  success   Boolean
  response  String   @db.Char(66) // bytes32
  timestamp DateTime @default(now())
}

model Approval {
  proposal   Proposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  proposalId String   @db.Char(66) // bytes32
  user       User     @relation(fields: [userId], references: [id])
  userId     String   @db.Char(42) // address

  signature String? // bytes; rejected if null
  createdAt DateTime @default(now())

  @@id([proposalId, userId])
}

model ContractMethod {
  contract String @default("0x0000000000000000000000000000000000000000") @db.Char(42) // address
  sighash  String @db.Char(10) // bytes4
  fragment Json

  @@id([contract, sighash])
  @@index([sighash])
}

////////////////////////////////////////////////////////////////
//                               COMMENT                      //
////////////////////////////////////////////////////////////////

model Comment {
  id Int @id @default(autoincrement())

  account   Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId String   @db.Char(42) // address
  key       String
  author    User     @relation(fields: [authorId], references: [id])
  authorId  String   @db.Char(42) // address
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()

  reactions Reaction[]

  @@index([accountId, key])
}

model Reaction {
  comment   Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId Int
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String  @db.Char(42) // address

  emojis    String[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()

  @@id([commentId, userId])
}
