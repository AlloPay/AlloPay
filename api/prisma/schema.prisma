datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

generator nestgraphql {
  provider = "prisma-nestjs-graphql"
  output   = "../generated"
}

model User {
  id        String  @id @db.Char(42) // address
  name      String?
  pushToken String?

  contacts  Contact[]
  approvals Approval[]
  comments  Comment[]
  reactions Reaction[]
  approvers Approver[]
  proposals Proposal[]
}

model Account {
  id         String  @id @db.Char(42) // address
  impl       String  @db.Char(42) // address
  deploySalt String  @db.Char(66) // bytes32
  name       String
  isActive   Boolean @default(false)

  quorums      Quorum[]
  quorumStates QuorumState[]
  proposals    Proposal[]
  comments     Comment[]
  reactions    Reaction[]
}

model Quorum {
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId String  @db.Char(42) // address
  key       Int
  name      String?

  states    QuorumState[]
  proposals Proposal[]

  @@id([accountId, key])
}

model QuorumState {
  id               Int              @id @default(autoincrement())
  account          Account          @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId        String           @db.Char(42) // address
  quorum           Quorum           @relation(fields: [accountId, quorumKey], references: [accountId, key], onDelete: Cascade)
  quorumKey        Int
  proposal         Proposal?        @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  proposalId       String?          @db.Char(66) // bytes32
  createdAt        DateTime         @default(now())
  isRemoved        Boolean          @default(false)
  spendingFallback SpendingFallback @default(allow)

  approvers Approver[]
  limits    TokenLimit[]

  @@index([accountId, quorumKey, createdAt(sort: Desc)], name: "quorum_createdAt")
}

model Approver {
  quorumState   QuorumState @relation(fields: [quorumStateId], references: [id], onDelete: Cascade)
  quorumStateId Int
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String      @db.Char(42) // address

  @@id([quorumStateId, userId])
}

enum SpendingFallback {
  allow
  deny
}

model TokenLimit {
  quorumState   QuorumState @relation(fields: [quorumStateId], references: [id], onDelete: Cascade)
  quorumStateId Int
  token         String      @db.Char(42) // address

  amount String //@db.Decimal(79, 0) // uint256
  period LimitPeriod

  @@id([quorumStateId, token])
}

enum LimitPeriod {
  Day
  Week
  Month
}

model Proposal {
  id String @id @db.Char(66) // hash: bytes32

  account    Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId  String   @db.Char(42) // address
  proposer   User     @relation(fields: [proposerId], references: [id])
  proposerId String   @db.Char(42) // address
  quorum     Quorum   @relation(fields: [accountId, quorumKey], references: [accountId, key])
  quorumKey  Int
  to         String   @db.Char(42) // address
  value      String? //@db.Decimal(79, 0) // uint256
  data       String? // bytes
  salt       String   @db.Char(18) // bytes8
  gasLimit   Decimal? @db.Decimal(19, 0)
  createdAt  DateTime @default(now())

  approvals    Approval[]
  transactions Transaction[]
  quorumStates QuorumState[]
}

model Transaction {
  hash String @id @db.Char(66) // bytes32

  proposal   Proposal             @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  proposalId String               @db.Char(66) // bytes32
  nonce      Int
  gasLimit   Decimal              @db.Decimal(19, 0)
  gasPrice   Decimal?             @db.Decimal(19, 0)
  createdAt  DateTime             @default(now())
  response   TransactionResponse?
}

model TransactionResponse {
  transaction     Transaction @relation(fields: [transactionHash], references: [hash], onDelete: Cascade)
  transactionHash String      @id @db.Char(66) // bytes32

  success   Boolean
  response  String   @db.Char(66) // bytes32
  timestamp DateTime @default(now())
}

model Approval {
  proposal   Proposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  proposalId String   @db.Char(66) // bytes32
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String   @db.Char(42) // address

  signature String? // bytes; rejected if undefined
  createdAt DateTime @default(now())

  @@id([proposalId, userId])
}

model Contact {
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @db.Char(42) // address
  addr   String @db.Char(42) // address
  name   String

  @@id([userId, addr])
  @@unique([userId, name], name: "name_identifier")
}

model ContractMethod {
  contract String @db.Char(42) // address
  sighash  String @db.Char(10) // bytes4
  fragment Json

  @@id([contract, sighash])
  @@index([sighash])
}

model Comment {
  id Int @id @default(autoincrement())

  account   Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId String   @db.Char(42) // address
  key       String
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  String   @db.Char(42) // address
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()

  reactions Reaction[]

  @@index([accountId, key])
}

model Reaction {
  comment   Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId Int
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String  @db.Char(42) // address

  emojis    String[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
  account   Account? @relation(fields: [accountId], references: [id])
  accountId String?  @db.Char(42)

  @@id([commentId, userId])
}
