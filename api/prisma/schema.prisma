datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

generator nestgraphql {
  provider = "prisma-nestjs-graphql"
  output   = "../generated"
}

model Device {
  id String @id @db.Char(42) // address

  users     User[]
  contacts  Contact[]
  approvals Approval[]
  comments  Comment[]
  reactions Reaction[]
  approvers Approver[]
}

model Account {
  id String @id @db.Char(42) // address

  impl       String  @db.Char(42) // address
  deploySalt String  @db.Char(66) // bytes32
  name       String
  isDeployed Boolean @default(false)

  users      User[]
  userStates UserState[]
  proposals  Proposal[]
  comments   Comment[]
  reactions  Reaction[]
}

model User {
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId String  @db.Char(42) // address
  device    Device  @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  deviceId  String  @db.Char(42) // address

  name String

  latestState UserState?  @relation(name: "latest")
  states      UserState[]
  proposals   Proposal[]

  @@id([accountId, deviceId])
}

model UserState {
  id Int @id @default(autoincrement())

  account      Account   @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId    String    @db.Char(42) // address
  user         User      @relation(fields: [accountId, deviceId], references: [accountId, deviceId], onDelete: Cascade)
  deviceId     String    @db.Char(42) // address
  proposal     Proposal? @relation(fields: [proposalHash], references: [hash], onDelete: Cascade)
  proposalHash String?   @db.Char(66) // bytes32
  createdAt    DateTime  @default(now())
  isDeleted    Boolean   @default(false)

  latestOfUser         User?        @relation(name: "latest", fields: [accountId, latestOfUserDeviceId], references: [accountId, deviceId], onDelete: Cascade) // user | null
  latestOfUserDeviceId String?      @db.Char(42)
  configs              UserConfig[]

  @@unique([accountId, latestOfUserDeviceId])
}

model UserConfig {
  id Int @id @default(autoincrement())

  state               UserState @relation(fields: [stateId], references: [id], onDelete: Cascade)
  stateId             Int
  spendingAllowlisted Boolean   @default(false)

  approvers Approver[]
  limits    TokenLimit[]
}

model Approver {
  config   UserConfig @relation(fields: [configId], references: [id], onDelete: Cascade)
  configId Int
  device   Device     @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  deviceId String     @db.Char(42) // address

  @@id([configId, deviceId])
}

enum LimitPeriod {
  Day
  Week
  Month
}

model TokenLimit {
  config   UserConfig @relation(fields: [configId], references: [id], onDelete: Cascade)
  configId Int
  token    String     @db.Char(42) // address

  amount String //@db.Decimal(79, 0) // uint256
  period LimitPeriod

  @@id([configId, token])
}

model Contact {
  device   Device @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  deviceId String @db.Char(42) // address
  addr     String @db.Char(42) // address
  name     String

  @@id([deviceId, addr])
  @@unique([deviceId, name], name: "name_identifier")
}

model ContractMethod {
  contract String @db.Char(42) // address
  sighash  String @db.Char(10) // bytes4
  fragment Json

  @@id([contract, sighash])
  @@index([sighash])
}

model Proposal {
  hash String @id @db.Char(66) // bytes32

  account    Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId  String   @db.Char(42) // address
  proposer   User     @relation(fields: [accountId, proposerId], references: [accountId, deviceId])
  proposerId String   @db.Char(42) // address
  to         String   @db.Char(42) // address
  value      String //@db.Decimal(79, 0) // uint256
  data       String // bytes
  salt       String   @db.Char(18) // bytes8
  gasLimit   Decimal? @db.Decimal(19, 0)
  createdAt  DateTime @default(now())

  approvals   Approval[]
  submissions Submission[]
  userStates  UserState[]
}

model Submission {
  hash String @id @db.Char(66) // bytes32

  proposal     Proposal            @relation(fields: [proposalHash], references: [hash], onDelete: Cascade)
  proposalHash String              @db.Char(66) // bytes32
  response     SubmissionResponse?
  nonce        Int
  gasLimit     Decimal             @db.Decimal(19, 0)
  gasPrice     Decimal?            @db.Decimal(19, 0)
  createdAt    DateTime            @default(now())
}

model SubmissionResponse {
  submission Submission @relation(fields: [hash], references: [hash], onDelete: Cascade)
  hash       String     @id @db.Char(66) // bytes32

  response  String   @db.Char(66) // bytes32
  reverted  Boolean  @default(false)
  timestamp DateTime @default(now())
}

model Approval {
  proposal     Proposal @relation(fields: [proposalHash], references: [hash], onDelete: Cascade)
  proposalHash String   @db.Char(66) // bytes32
  device       Device   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  deviceId     String   @db.Char(42) // address

  signature String // bytes
  createdAt DateTime @default(now())

  @@id([proposalHash, deviceId])
}

model Comment {
  id Int @id @default(autoincrement())

  account   Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId String   @db.Char(42) // address
  key       String
  author    Device   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  String   @db.Char(42) // address
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()

  reactions Reaction[]

  @@index([accountId, key])
}

model Reaction {
  comment   Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId Int
  device    Device  @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  deviceId  String  @db.Char(42) // address

  emojis    String[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
  account   Account? @relation(fields: [accountId], references: [id])
  accountId String?  @db.Char(42)

  @@id([commentId, deviceId])
}
