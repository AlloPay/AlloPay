datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

generator nestgraphql {
  provider = "prisma-nestjs-graphql"
  output   = "../generated"
}

model Device {
  id String @id @db.Char(42) // address

  users     User[]
  contacts  Contact[]
  approvals Approval[]
  comments  Comment[]
  reactions Reaction[]
  approvers Approver[]
}

model Account {
  id         String  @id @db.Char(42) // address
  name       String  @default("")
  deploySalt String? @db.Char(66) // bytes32
  impl       String? @db.Char(42) // address

  users     User[]
  proposals Proposal[]
  approvals Approval[]
  comments  Comment[]
  reactions Reaction[]
}

model User {
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId String  @db.Char(42) // address
  device    Device  @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  deviceId  String  @db.Char(42) // address

  name String

  states UserState[]

  @@id([accountId, deviceId])
}

model UserState {
  id Int @id @default(autoincrement())

  user         User      @relation(fields: [accountId, deviceId], references: [accountId, deviceId], onDelete: Cascade)
  accountId    String    @db.Char(42) // address
  deviceId     String    @db.Char(42) // address
  proposal     Proposal? @relation(fields: [proposalHash], references: [hash], onDelete: Cascade)
  proposalHash String?   @db.Char(66) // bytes32
  createdAt    DateTime  @default(now())
  isDeleted    Boolean   @default(false)

  configs UserConfig[]
}

model UserConfig {
  id Int @id @default(autoincrement())

  state               UserState @relation(fields: [stateId], references: [id], onDelete: Cascade)
  stateId             Int
  spendingAllowlisted Boolean   @default(false)

  approvers Approver[]
  limits    TokenLimit[]
}

model Approver {
  config   UserConfig @relation(fields: [configId], references: [id], onDelete: Cascade)
  configId Int
  device   Device     @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  deviceId String     @db.Char(42) // address

  @@id([configId, deviceId])
}

enum LimitPeriod {
  Day
  Week
  Month
}

model TokenLimit {
  config   UserConfig @relation(fields: [configId], references: [id], onDelete: Cascade)
  configId Int
  token    String     @db.Char(42) // address

  amount String //@db.Decimal(79, 0) // uint256
  period LimitPeriod

  @@id([configId, token])
}

model Contact {
  device   Device @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  deviceId String @db.Char(42) // address
  addr     String @db.Char(42) // address
  name     String

  @@id([deviceId, addr])
  @@unique([deviceId, name], name: "name_identifier")
}

model ContractMethod {
  contract String @db.Char(42) // address
  sighash  String @db.Char(10) // bytes4
  fragment Json

  @@id([contract, sighash])
  @@index([sighash])
}

model Proposal {
  hash String @id @db.Char(66) // bytes32

  account   Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId String   @db.Char(42) // address
  to        String   @db.Char(42) // address
  value     String //@db.Decimal(79, 0) // uint256
  data      String // bytes
  salt      String   @db.Char(18) // bytes8
  createdAt DateTime @default(now())

  approvals   Approval[]
  submissions Submission[]
  userStates  UserState[]
}

model Submission {
  hash String @id @db.Char(66) // bytes32

  proposal     Proposal @relation(fields: [proposalHash], references: [hash], onDelete: Cascade)
  proposalHash String   @db.Char(66) // bytes32
  nonce        Int
  gasLimit     Decimal  @db.Decimal(19, 0)
  gasPrice     Decimal? @db.Decimal(19, 0)
  finalized    Boolean
  createdAt    DateTime @default(now())
}

model Approval {
  account      Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId    String   @db.Char(42) // address
  proposal     Proposal @relation(fields: [proposalHash], references: [hash], onDelete: Cascade)
  proposalHash String   @db.Char(66) // bytes32
  device       Device   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  deviceId     String   @db.Char(42) // address

  signature String // bytes
  createdAt DateTime @default(now())

  @@id([accountId, proposalHash, deviceId])
}

model Comment {
  id Int @id @default(autoincrement())

  account   Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId String   @db.Char(42) // address
  key       String
  author    Device   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  String   @db.Char(42) // address
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()

  reactions Reaction[]

  @@index([accountId, key])
}

model Reaction {
  comment   Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId Int
  device    Device  @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  deviceId  String  @db.Char(42) // address

  emojis    String[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
  account   Account? @relation(fields: [accountId], references: [id])
  accountId String?  @db.Char(42)

  @@id([commentId, deviceId])
}
