# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

scalar AbiFunction @specifiedBy(url: "https://docs.soliditylang.org/en/latest/abi-spec.html#json")

enum AbiSource {
  Verified
}

enum AbiSourceConfidence {
  High
  Low
  Medium
}

type Account implements Node {
  address: UAddress!
  approvers: [Approver!]!
  chain: Chain!
  id: ID!
  implementation: Address!
  isActive: Boolean!
  label: String!
  name: String!
  photoUri: String
  policies: [Policy!]!
  proposals: [Proposal!]!
  salt: Bytes32!
  transactionProposals: [TransactionProposal!]!
  transfers: [Transfer!]!
}

enum AccountEvent {
  create
  update
}

input AccountInput {
  """Defaults to random user account"""
  account: UAddress
}

input AccountSubscriptionInput {
  """Defaults to user accounts"""
  accounts: [UAddress!]

  """Defaults to all events"""
  events: AccountEvent
}

type Action implements Node {
  allow: Boolean!
  description: String
  functions: [ActionFunction!]!
  id: ID!
  label: String!
}

type ActionFunction implements Node {
  abi: AbiFunction

  """Default: apply to all contracts"""
  contract: Address
  id: ID!

  """Default: apply to all selectors"""
  selector: Selector
}

input ActionFunctionInput {
  abi: AbiFunction

  """Default: apply to all contracts"""
  contract: Address

  """Default: apply to all selectors"""
  selector: Selector
}

input ActionInput {
  allow: Boolean!
  description: String
  functions: [ActionFunctionInput!]!
  label: String!
}

"""Ethereum address"""
scalar Address

type Approval implements Node & ProposalResponse {
  approver: Approver!
  createdAt: DateTime!
  id: ID!
  proposal: Proposal!
}

input ApproveInput {
  """Defaults to current approver"""
  approver: Address
  hash: Bytes32!
  signature: Bytes!
}

type Approver implements Node {
  address: Address!
  id: ID!
  label: String
}

input ApproverInput {
  """Defaults to current approver"""
  address: Address
}

input BalanceInput {
  account: UAddress
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

"""bytes hex string"""
scalar Bytes

"""32-byte hex string"""
scalar Bytes32

"""zksync | zksync-goerli | zksync-local"""
scalar Chain

enum CloudProvider {
  Apple
  Google
}

type CloudShare implements Node {
  id: ID!
  provider: CloudProvider!
  subject: String!
}

input CloudShareInput {
  idToken: JWT!
  share: String!
}

type Contact {
  address: UAddress!
  id: ID!
  label: String!
}

input ContactInput {
  address: UAddress!
}

input ContactsInput {
  query: String
}

type Contract {
  address: Address!
  functions: [ContractFunction!]!
  id: ID!
}

type ContractFunction {
  abi: JSON!
  abiMd5: String!
  id: ID!
  selector: Selector!
  source: AbiSource!
  sourceConfidence: AbiSourceConfidence!
}

input ContractFunctionInput {
  contract: Address!
  selector: Bytes!
}

input ContractInput {
  contract: Address!
}

input CreateAccountInput {
  chain: Chain
  label: String!
  policies: [PolicyInput!]!
}

input CreatePolicyInput {
  account: UAddress!
  actions: [ActionInput!]
  approvers: [Address!]
  name: String
  threshold: Float
  transfers: TransfersConfigInput
}

union CreatePolicyResponse = NameTaken | Policy

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

"""Decimal"""
scalar Decimal

interface Err {
  message: String!
}

input EstimateFeesPerGasInput {
  feeToken: UAddress!
}

type EstimatedTransactionFees implements Node {
  ethDiscount: Decimal!
  id: ID!
  maxNetworkEthFee: Decimal!
}

union Event = Transfer | TransferApproval

interface EventBase {
  account: Account!
  block: BigInt!
  id: ID!
  logIndex: Float!
  timestamp: DateTime!
}

type FeesPerGas implements Node {
  feeTokenDecimals: Float!
  id: ID!
  maxFeePerGas: Decimal!
  maxPriorityFeePerGas: Decimal!
}

type GenericOp {
  _args: [JSON!]!
  _name: String!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""
A field whose value is a JSON Web Token (JWT): https://jwt.io/introduction.
"""
scalar JWT

input LabelAvailableInput {
  label: String!
}

input LabelInput {
  address: UAddress!
}

input LabelProposalRiskInput {
  hash: Bytes32!
  risk: Risk!
}

input LinkInput {
  token: String!
}

"""
A field whose value is a IEEE 802 48-bit MAC address: https://en.wikipedia.org/wiki/MAC_address.
"""
scalar MAC

type MessageProposal implements Node & Proposal {
  account: Account!
  approvals: [Approval!]!
  createdAt: DateTime!
  hash: Bytes32!
  iconUri: String
  id: ID!
  label: String
  message: String!
  policy: Policy
  potentialApprovers: [Approver!]!
  potentialRejectors: [Approver!]!
  proposedBy: Approver!
  rejections: [Rejection!]!
  riskLabel: Risk
  signature: Bytes32
  typedData: TypedData
  updatable: Boolean!
  validFrom: DateTime!
}

type Mutation {
  approveMessage(input: ApproveInput!): MessageProposal!
  approveTransaction(input: ApproveInput!): TransactionProposal!
  createAccount(input: CreateAccountInput!): Account!
  createPolicy(input: CreatePolicyInput!): CreatePolicyResponse!
  deleteContact(input: ContactInput!): ID
  execute(input: ProposalInput!): TransactionProposal
  labelProposalRisk(input: LabelProposalRiskInput!): Proposal!
  link(input: LinkInput!): User!
  proposeMessage(input: ProposeMessageInput!): MessageProposal!
  proposeTransaction(input: ProposeTransactionInput!): TransactionProposal!
  rejectProposal(input: ProposalInput!): Proposal!
  removeMessage(input: ProposalInput!): ID!
  removePolicy(input: UniquePolicyInput!): Policy!
  removeToken(input: TokenInput!): ID
  removeTransaction(input: ProposalInput!): ID
  requestTokens(input: RequestTokensInput!): [Address!]!
  updateAccount(input: UpdateAccountInput!): Account!
  updateApprover(input: UpdateApproverInput!): UserApprover!
  updatePolicy(input: UpdatePolicyInput!): UpdatePolicyResponse!
  updateProposal(input: UpdateProposalInput!): Proposal!
  updateTransaction(input: UpdateTransactionProposalInput!): TransactionProposal!
  updateUser(input: UpdateUserInput!): User!
  upsertContact(input: UpsertContactInput!): Contact!
  upsertToken(input: UpsertTokenInput!): Token!
}

type NameTaken implements Err {
  message: String!
}

interface Node {
  id: ID!
}

type Operation {
  data: Bytes
  function: OperationFunction
  to: Address!
  value: Uint256
}

union OperationFunction = GenericOp | RemovePolicyOp | SwapOp | TransferApprovalOp | TransferFromOp | TransferOp | UpdatePolicyOp

input OperationInput {
  data: Bytes
  to: Address!
  value: Uint256
}

input PoliciesInput {
  includeDisabled: Boolean! = false
}

type Policy {
  account: Account!
  draft: PolicyState
  id: ID!
  isActive: Boolean!
  key: PolicyKey!
  name: String!
  satisfiability(input: SatisfiabilityInput!): SatisfiabilityResult!
  state: PolicyState
  stateHistory: [PolicyState!]!
}

input PolicyInput {
  actions: [ActionInput!]
  approvers: [Address!]
  name: String
  threshold: Float
  transfers: TransfersConfigInput
}

"""Policy key: an unsigned integer [0, 65535]"""
scalar PolicyKey

type PolicyState {
  actions: [Action!]!
  activationBlock: BigInt
  approvers: [Approver!]!
  createdAt: DateTime!
  id: ID!
  isAccountInitState: Boolean!
  isRemoved: Boolean!
  proposal: TransactionProposal
  threshold: Float!
  transfers: TransfersConfig!
}

type Price implements Node {
  eth: Decimal!
  ethEma: Decimal!

  """Pyth USD price id"""
  id: ID!
  usd: Decimal!
  usdEma: Decimal!
}

interface Proposal implements Node {
  account: Account!
  approvals: [Approval!]!
  createdAt: DateTime!
  hash: Bytes32!
  iconUri: String
  id: ID!
  label: String
  policy: Policy
  potentialApprovers: [Approver!]!
  potentialRejectors: [Approver!]!
  proposedBy: Approver!
  rejections: [Rejection!]!
  riskLabel: Risk
  validFrom: DateTime!
}

enum ProposalEvent {
  approval
  approved
  create
  delete
  executed
  rejection
  submitted
  update
}

input ProposalInput {
  hash: Bytes32!
}

interface ProposalResponse implements Node {
  approver: Approver!
  createdAt: DateTime!
  id: ID!
  proposal: Proposal!
}

input ProposalSubscriptionInput {
  """Defaults to user accounts if no proposals are provided"""
  accounts: [UAddress!]

  """Defaults to all events"""
  events: [ProposalEvent!]
  proposals: [Bytes32!]
}

input ProposalsInput {
  accounts: [UAddress!]
  pending: Boolean
}

input ProposeMessageInput {
  account: UAddress!
  iconUri: String
  label: String

  """Optional if typedData is provided"""
  message: String

  """Approve the proposal"""
  signature: Bytes
  typedData: TypedData
  validFrom: DateTime
}

input ProposeTransactionInput {
  account: UAddress!
  feeToken: Address
  gas: Uint256
  iconUri: String
  label: String
  operations: [OperationInput!]!

  """Approve the proposal"""
  signature: Bytes
  validFrom: DateTime
}

type Query {
  account(input: AccountInput! = {}): Account
  accounts: [Account!]!
  approver(input: ApproverInput! = {}): UserApprover
  cloudShare(input: UniqueCloudShareInput!): String
  contact(input: ContactInput!): Contact
  contacts(input: ContactsInput! = {}): [Contact!]!
  contract(input: ContractInput!): Contract
  contractFunction(input: ContractFunctionInput!): ContractFunction
  estimateFeesPerGas(input: EstimateFeesPerGasInput!): FeesPerGas
  label(input: LabelInput!): String
  labelAvailable(input: LabelAvailableInput!): Boolean!
  messageProposal(input: ProposalInput!): MessageProposal
  policies(input: PoliciesInput! = {}): [Policy!]!
  policy(input: UniquePolicyInput!): Policy
  proposal(input: ProposalInput!): Proposal
  proposals(input: ProposalsInput! = {}): [Proposal!]!
  requestableTokens(input: RequestTokensInput!): [Address!]!
  token(input: TokenInput!): Token
  tokenMetadata(input: TokenInput!): TokenMetadata!
  tokens(input: TokensInput! = {}): [Token!]!
  transaction(input: TransactionInput!): Transaction
  transactionProposal(input: ProposalInput!): TransactionProposal
  transactionProposals(input: TransactionProposalsInput!): [TransactionProposal!]!
  transfers(input: TransfersInput! = {}): [Transfer!]!
  user: User!
}

type Receipt {
  block: BigInt!
  ethFeePerGas: Decimal!
  ethFees: Decimal!
  events: [Event!]!
  gasUsed: BigInt!
  id: ID!
  networkEthFee: Decimal!
  responses: [Bytes!]!
  success: Boolean!
  timestamp: DateTime!
  transferApprovalEvents: [TransferApproval!]!
  transferEvents: [Transfer!]!
}

type Rejection implements Node & ProposalResponse {
  approver: Approver!
  createdAt: DateTime!
  id: ID!
  proposal: Proposal!
}

type RemovePolicyOp {
  _args: [JSON!]!
  _name: String!
  account: Address!
  key: PolicyKey!
}

input RequestTokensInput {
  account: UAddress!
}

enum Risk {
  High
  Low
  Medium
}

enum Satisfiability {
  satisfiable
  satisfied
  unsatisfiable
}

input SatisfiabilityInput {
  proposal: Bytes32!
}

type SatisfiabilityReason {
  operation: Float
  reason: String!
}

type SatisfiabilityResult {
  reasons: [SatisfiabilityReason!]!
  result: Satisfiability!
}

"""function selector (4-byte hex string)"""
scalar Selector

type Simulation implements Node {
  id: ID!
  transfers: [SimulationTransfer!]!
}

type SimulationTransfer implements TransferDetails {
  account: Account!
  amount: Decimal!
  from: Address!
  id: ID!
  isFeeTransfer: Boolean!
  to: Address!
  token: Token
  tokenAddress: UAddress!
  value: Decimal
}

type Subscription {
  account(input: AccountSubscriptionInput! = {}): Account!
  proposal(input: ProposalSubscriptionInput! = {}): Proposal!
  transfer(input: TransferSubscriptionInput! = {}): Transfer!
  user: User!
}

type SwapOp {
  _args: [JSON!]!
  _name: String!
  deadline: DateTime!
  fromAmount: Decimal!
  fromToken: Address!
  minimumToAmount: Decimal!
  toToken: Address!
}

type Token implements Node {
  address: UAddress!
  balance(input: BalanceInput!): Decimal!
  decimals: Int!
  estimatedFeesPerGas: FeesPerGas
  iconUri: String
  id: ID!
  isFeeToken: Boolean!
  name: String!
  price: Price
  pythUsdPriceId: Bytes32
  removable: Boolean!
  symbol: String!
  units: [TokenUnit!]
  userOwned: Boolean!
}

input TokenInput {
  address: UAddress!
}

type TokenMetadata {
  decimals: Int
  iconUri: String
  id: ID!
  name: String
  pythUsdPriceId: Bytes32
  symbol: String
}

type TokenUnit {
  decimals: Int!
  symbol: String!
}

input TokenUnitInput {
  decimals: Int!
  symbol: String!
}

input TokensInput {
  address: [UAddress!]
  chain: Chain
  feeToken: Boolean
  query: String
}

type Transaction implements Node {
  ethDiscount: Decimal!
  ethPerFeeToken: Decimal!
  hash: Bytes32!
  id: ID!
  maxEthFeePerGas: Decimal!
  maxEthFees: Decimal!
  maxNetworkEthFee: Decimal!
  proposal: TransactionProposal!
  receipt: Receipt
  submittedAt: DateTime!
  usdPerFeeToken: Decimal!
}

input TransactionInput {
  hash: Bytes32!
}

type TransactionProposal implements Node & Proposal {
  account: Account!
  approvals: [Approval!]!
  createdAt: DateTime!
  estimatedFees: EstimatedTransactionFees!
  feeToken: Token!
  gasLimit: BigInt!
  hash: Bytes32!
  iconUri: String
  id: ID!
  label: String
  nonce: BigInt!
  operations: [Operation!]!
  paymaster: Address!
  paymasterEthFee: Decimal!
  policy: Policy
  potentialApprovers: [Approver!]!
  potentialRejectors: [Approver!]!
  proposedBy: Approver!
  rejections: [Rejection!]!
  riskLabel: Risk
  simulation: Simulation
  status: TransactionProposalStatus!
  transaction: Transaction
  transactions: [Transaction!]!
  updatable: Boolean!
  validFrom: DateTime!
}

enum TransactionProposalStatus {
  Executing
  Failed
  Pending
  Successful
}

input TransactionProposalsInput {
  accounts: [UAddress!]
  statuses: [TransactionProposalStatus!]
}

type Transfer implements EventBase & TransferDetails & Transferlike {
  account: Account!
  amount: Decimal!
  block: BigInt!
  from: Address!
  id: ID!
  isFeeTransfer: Boolean!
  logIndex: Float!
  timestamp: DateTime!
  to: Address!
  token: Token
  tokenAddress: UAddress!
  value: Decimal
}

type TransferApproval implements EventBase & TransferDetails & Transferlike {
  account: Account!
  amount: Decimal!
  block: BigInt!
  delta: Decimal!
  from: Address!
  id: ID!
  isFeeTransfer: Boolean!
  logIndex: Float!
  timestamp: DateTime!
  to: Address!
  token: Token
  tokenAddress: UAddress!
  value: Decimal
}

type TransferApprovalOp {
  _args: [JSON!]!
  _name: String!
  amount: Decimal!
  spender: Address!
  token: Address!
}

interface TransferDetails {
  account: Account!
  amount: Decimal!
  from: Address!
  id: ID!
  isFeeTransfer: Boolean!
  to: Address!
  token: Token
  tokenAddress: UAddress!
  value: Decimal
}

enum TransferDirection {
  In
  Out
}

type TransferFromOp {
  _args: [JSON!]!
  _name: String!
  amount: Decimal!
  from: Address!
  to: Address!
  token: Address!
}

type TransferLimit {
  amount: BigInt!

  """seconds"""
  duration: Float!
  id: ID!
  token: Address!
}

input TransferLimitInput {
  amount: BigInt!

  """seconds"""
  duration: Float!
  token: Address!
}

type TransferOp {
  _args: [JSON!]!
  _name: String!
  amount: Decimal!
  to: Address!
  token: Address!
}

input TransferSubscriptionInput {
  accounts: [UAddress!]
  direction: TransferDirection

  """Originating from an account transaction"""
  internal: Boolean
}

interface Transferlike implements EventBase & TransferDetails {
  account: Account!
  amount: Decimal!
  block: BigInt!
  from: Address!
  id: ID!
  isFeeTransfer: Boolean!
  logIndex: Float!
  timestamp: DateTime!
  to: Address!
  token: Token
  tokenAddress: UAddress!
  value: Decimal
}

type TransfersConfig {
  budget: Float!
  defaultAllow: Boolean!
  id: ID!
  limits: [TransferLimit!]!
}

input TransfersConfigInput {
  """Defaults to the policy budget"""
  budget: Float
  defaultAllow: Boolean! = true
  limits: [TransferLimitInput!]! = []
}

input TransfersInput {
  accounts: [UAddress!]
  direction: TransferDirection

  """Originating from an account transaction"""
  internal: Boolean
}

"""EIP712 Typed Data"""
scalar TypedData

"""EIP-3770 address"""
scalar UAddress @specifiedBy(url: "https://eips.ethereum.org/EIPS/eip-3770")

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

"""256-bit unsigned integer"""
scalar Uint256

input UniqueCloudShareInput {
  idToken: JWT!
}

input UniquePolicyInput {
  account: UAddress!
  key: PolicyKey!
}

input UpdateAccountInput {
  account: UAddress!
  label: String!
  photoUri: URL
}

input UpdateApproverInput {
  """Defaults to current approver"""
  address: Address
  bluetoothDevices: [MAC!]
  cloud: CloudShareInput
  name: String
  pushToken: String
}

input UpdatePolicyInput {
  account: UAddress!
  actions: [ActionInput!]
  approvers: [Address!]
  key: PolicyKey!
  name: String
  threshold: Float
  transfers: TransfersConfigInput
}

type UpdatePolicyOp {
  _args: [JSON!]!
  _name: String!
  account: Address!
  approvers: [Address!]!
  key: PolicyKey!
  threshold: Float!
}

union UpdatePolicyResponse = NameTaken | Policy

input UpdateProposalInput {
  hash: Bytes32!
  policy: PolicyKey
}

input UpdateTransactionProposalInput {
  feeToken: Address
  hash: Bytes32!
  policy: PolicyKey
}

input UpdateUserInput {
  primaryAccount: UAddress
}

input UpsertContactInput {
  address: UAddress!
  label: String!
  previousAddress: UAddress
}

input UpsertTokenInput {
  address: UAddress!
  decimals: Int
  iconUri: String
  name: String
  pythUsdPriceId: Bytes32
  symbol: String
  units: [TokenUnitInput!]! = []
}

type User {
  approvers: [UserApprover!]!
  contacts: [Contact!]!
  id: ID!
  linkingToken: String!
  primaryAccount: Account
}

type UserApprover implements Node {
  address: Address!
  bluetoothDevices: [MAC!]
  cloud: CloudShare
  id: ID!
  label: String
  name: String
  pushToken: String
}