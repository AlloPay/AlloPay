# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

enum AbiSource {
  DECOMPILED
  STANDARD
  VERIFIED
}

type Account {
  deploySalt: Bytes32!
  id: Address!
  impl: Address!
  isActive: Boolean!
  name: String!
  policies: [Policy!]
  policyStates: [PolicyState!]
  proposals: [Proposal!]
  transfers: [Transfer!]
}

enum AccountEvent {
  create
  update
}

input AccountOrderByWithRelationInput {
  deploySalt: SortOrder
  id: SortOrder
  impl: SortOrder
  isActive: SortOrder
  name: SortOrder
  policies: PolicyOrderByRelationAggregateInput
  policyStates: PolicyStateOrderByRelationAggregateInput
  proposals: ProposalOrderByRelationAggregateInput
  transfers: TransferOrderByRelationAggregateInput
}

input AccountRelationFilter {
  is: AccountWhereInput
  isNot: AccountWhereInput
}

enum AccountScalarFieldEnum {
  deploySalt
  id
  impl
  isActive
  name
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  deploySalt: StringFilter
  id: StringFilter
  impl: StringFilter
  isActive: BoolFilter
  name: StringFilter
  policies: PolicyListRelationFilter
  policyStates: PolicyStateListRelationFilter
  proposals: ProposalListRelationFilter
  transfers: TransferListRelationFilter
}

input AccountWhereUniqueInput {
  id: String
}

"""Ethereum address"""
scalar Address

type Approval {
  createdAt: DateTime!
  proposal: Proposal!
  proposalId: Bytes32!
  signature: Bytes
  user: User!
  userId: Address!
}

input ApprovalListRelationFilter {
  every: ApprovalWhereInput
  none: ApprovalWhereInput
  some: ApprovalWhereInput
}

input ApprovalOrderByRelationAggregateInput {
  _count: SortOrder
}

input ApprovalWhereInput {
  AND: [ApprovalWhereInput!]
  NOT: [ApprovalWhereInput!]
  OR: [ApprovalWhereInput!]
  createdAt: DateTimeFilter
  proposal: ProposalRelationFilter
  proposalId: StringFilter
  signature: StringNullableFilter
  user: UserRelationFilter
  userId: StringFilter
}

type Approver {
  id: String!
  state: PolicyState!
  stateId: BigInt!
  user: User!
  userId: Address!
}

input ApproverListRelationFilter {
  every: ApproverWhereInput
  none: ApproverWhereInput
  some: ApproverWhereInput
}

input ApproverOrderByRelationAggregateInput {
  _count: SortOrder
}

input ApproverWhereInput {
  AND: [ApproverWhereInput!]
  NOT: [ApproverWhereInput!]
  OR: [ApproverWhereInput!]
  state: PolicyStateRelationFilter
  stateId: BigIntFilter
  user: UserRelationFilter
  userId: StringFilter
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

input BigIntFilter {
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntFilter
  notIn: [BigInt!]
}

input BigIntNullableFilter {
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntNullableFilter
  notIn: [BigInt!]
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

"""bytes hex string"""
scalar Bytes

"""32-byte hex string"""
scalar Bytes32

type Contact {
  addr: Address!
  id: String!
  name: String!
}

input ContactListRelationFilter {
  every: ContactWhereInput
  none: ContactWhereInput
  some: ContactWhereInput
}

input ContactName_identifierCompoundUniqueInput {
  name: String!
  userId: String!
}

input ContactOrderByRelationAggregateInput {
  _count: SortOrder
}

input ContactOrderByWithRelationInput {
  addr: SortOrder
  name: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum ContactScalarFieldEnum {
  addr
  name
  userId
}

input ContactUserIdAddrCompoundUniqueInput {
  addr: String!
  userId: String!
}

input ContactWhereInput {
  AND: [ContactWhereInput!]
  NOT: [ContactWhereInput!]
  OR: [ContactWhereInput!]
  addr: StringFilter
  name: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

input ContactWhereUniqueInput {
  name_identifier: ContactName_identifierCompoundUniqueInput
  userId_addr: ContactUserIdAddrCompoundUniqueInput
}

type Contract {
  functions: [ContractFunction!]
  id: Address!
}

type ContractFunction {
  abi: JSON!
  contract: Contract
  contractId: Address
  id: Float!
  selector: Selector!
  source: AbiSource!
  sourceConfidence: ContractSourceConfidence!
}

input ContractFunctionInput {
  contract: Address!
  selector: Bytes!
}

input ContractInput {
  contract: Address!
}

enum ContractSourceConfidence {
  High
  Low
  Medium
}

input CreateAccountInput {
  name: String!
  policies: [PolicyInput!]!
}

input CreatePolicyInput {
  account: Address!

  """Signers that are required to approve"""
  approvers: [Address!]
  key: PolicyKey
  name: String
  permissions: PermissionsInput!

  """Defaults to all approvers"""
  threshold: Float
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

"""An arbitrary-precision Decimal type"""
scalar Decimal

input DecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal!]
}

input DecimalNullableFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableFilter
  notIn: [Decimal!]
}

input EnumTransferDirectionFilter {
  equals: TransferDirection
  in: [TransferDirection!]
  not: NestedEnumTransferDirectionFilter
  notIn: [TransferDirection!]
}

type ExplorerTransfer {
  amount: Uint256!
  from: Address!
  id: String!
  timestamp: DateTime!
  to: Address!
  token: Address!
  transferNumber: Float!
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Mutation {
  approve(id: Bytes32!, signature: Bytes!): Proposal!
  createAccount(args: CreateAccountInput!): Account!
  createPolicy(args: CreatePolicyInput!): Policy!
  deleteContact(addr: Address!): Contact!
  propose(
    account: Address!
    data: Bytes
    feeToken: Address
    gasLimit: Uint256
    nonce: Uint256

    """Approve the proposal"""
    signature: Bytes
    to: Address!

    """WEI"""
    value: Uint256
  ): Proposal!
  reject(id: Bytes32!): Proposal!
  removePolicy(args: UniquePolicyInput!): Policy!
  removeProposal(id: Bytes32!): Proposal!
  requestTokens(account: Address!): [Address!]!
  updateAccount(args: UpdateAccountInput!): Account!
  updatePolicy(args: UpdatePolicyInput!): Policy!
  updateUser(name: String, pushToken: String): User!
  upsertContact(name: String!, newAddr: Address!, prevAddr: Address): Contact!
}

input NestedBigIntFilter {
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntFilter
  notIn: [BigInt!]
}

input NestedBigIntNullableFilter {
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntNullableFilter
  notIn: [BigInt!]
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal!]
}

input NestedDecimalNullableFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableFilter
  notIn: [Decimal!]
}

input NestedEnumTransferDirectionFilter {
  equals: TransferDirection
  in: [TransferDirection!]
  not: NestedEnumTransferDirectionFilter
  notIn: [TransferDirection!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input PermissionsInput {
  """Targets that can be called"""
  targets: [TargetInput!]
}

type Policy {
  account: Account!
  accountId: Address!
  active: PolicyState
  activeId: BigInt
  draft: PolicyState
  draftId: BigInt
  id: String!
  key: BigInt!
  name: String!
  states: [PolicyState!]
}

input PolicyAccountIdKeyCompoundUniqueInput {
  accountId: String!
  key: BigInt!
}

input PolicyAccountIdNameCompoundUniqueInput {
  accountId: String!
  name: String!
}

input PolicyInput {
  """Signers that are required to approve"""
  approvers: [Address!]
  key: PolicyKey
  name: String
  permissions: PermissionsInput!

  """Defaults to all approvers"""
  threshold: Float
}

"""Policy key: an unsigned integer [0, 4294967295]"""
scalar PolicyKey

input PolicyListRelationFilter {
  every: PolicyWhereInput
  none: PolicyWhereInput
  some: PolicyWhereInput
}

input PolicyOrderByRelationAggregateInput {
  _count: SortOrder
}

input PolicyOrderByWithRelationInput {
  account: AccountOrderByWithRelationInput
  accountId: SortOrder
  active: PolicyStateOrderByWithRelationInput
  activeId: SortOrder
  draft: PolicyStateOrderByWithRelationInput
  draftId: SortOrder
  key: SortOrder
  name: SortOrder
  states: PolicyStateOrderByRelationAggregateInput
}

input PolicyRelationFilter {
  is: PolicyWhereInput
  isNot: PolicyWhereInput
}

enum PolicyScalarFieldEnum {
  accountId
  activeId
  draftId
  key
  name
}

type PolicyState {
  account: Account!
  accountId: String!
  activeOf: Policy
  approvers: [Approver!]
  createdAt: DateTime!
  draftOf: Policy
  id: BigInt!
  isRemoved: Boolean!
  policy: Policy!
  policyKey: BigInt!
  proposal: Proposal
  proposalId: String
  targets: [Target!]
  threshold: Float!
}

input PolicyStateListRelationFilter {
  every: PolicyStateWhereInput
  none: PolicyStateWhereInput
  some: PolicyStateWhereInput
}

input PolicyStateOrderByRelationAggregateInput {
  _count: SortOrder
}

input PolicyStateOrderByWithRelationInput {
  account: AccountOrderByWithRelationInput
  accountId: SortOrder
  activeOf: PolicyOrderByWithRelationInput
  approvers: ApproverOrderByRelationAggregateInput
  createdAt: SortOrder
  draftOf: PolicyOrderByWithRelationInput
  id: SortOrder
  isRemoved: SortOrder
  policy: PolicyOrderByWithRelationInput
  policyKey: SortOrder
  proposal: ProposalOrderByWithRelationInput
  proposalId: SortOrder
  targets: TargetOrderByRelationAggregateInput
  threshold: SortOrder
}

input PolicyStateRelationFilter {
  is: PolicyStateWhereInput
  isNot: PolicyStateWhereInput
}

input PolicyStateWhereInput {
  AND: [PolicyStateWhereInput!]
  NOT: [PolicyStateWhereInput!]
  OR: [PolicyStateWhereInput!]
  account: AccountRelationFilter
  accountId: StringFilter
  activeOf: PolicyRelationFilter
  approvers: ApproverListRelationFilter
  createdAt: DateTimeFilter
  draftOf: PolicyRelationFilter
  id: BigIntFilter
  isRemoved: BoolFilter
  policy: PolicyRelationFilter
  policyKey: BigIntFilter
  proposal: ProposalRelationFilter
  proposalId: StringNullableFilter
  targets: TargetListRelationFilter
  threshold: IntFilter
}

input PolicyWhereInput {
  AND: [PolicyWhereInput!]
  NOT: [PolicyWhereInput!]
  OR: [PolicyWhereInput!]
  account: AccountRelationFilter
  accountId: StringFilter
  active: PolicyStateRelationFilter
  activeId: BigIntNullableFilter
  draft: PolicyStateRelationFilter
  draftId: BigIntNullableFilter
  key: BigIntFilter
  name: StringFilter
  states: PolicyStateListRelationFilter
}

input PolicyWhereUniqueInput {
  accountId_key: PolicyAccountIdKeyCompoundUniqueInput
  accountId_name: PolicyAccountIdNameCompoundUniqueInput
  activeId: BigInt
  draftId: BigInt
}

type Proposal {
  account: Account!
  accountId: Address!
  approvals: [Approval!]
  createdAt: DateTime!
  data: Bytes
  estimatedOpGas: BigInt!
  feeToken: Address
  gasLimit: BigInt
  id: Bytes32!
  nonce: BigInt!
  policyStates: [PolicyState!]
  proposer: User!
  proposerId: Address!
  rejections: [Rejection!]!
  satisfiablePolicies: [SatisfiablePolicy!]!
  simulation: Simulation
  to: Address!
  transaction: Transaction
  transactions: [Transaction!]
  value: Decimal
}

enum ProposalEvent {
  create
  delete
  execute
  response
  update
}

input ProposalListRelationFilter {
  every: ProposalWhereInput
  none: ProposalWhereInput
  some: ProposalWhereInput
}

input ProposalOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProposalOrderByWithRelationInput {
  account: AccountOrderByWithRelationInput
  accountId: SortOrder
  approvals: ApprovalOrderByRelationAggregateInput
  createdAt: SortOrder
  data: SortOrder
  estimatedOpGas: SortOrder
  feeToken: SortOrder
  gasLimit: SortOrder
  id: SortOrder
  nonce: SortOrder
  policyStates: PolicyStateOrderByRelationAggregateInput
  proposer: UserOrderByWithRelationInput
  proposerId: SortOrder
  simulation: SimulationOrderByWithRelationInput
  to: SortOrder
  transactions: TransactionOrderByRelationAggregateInput
  value: SortOrder
}

input ProposalRelationFilter {
  is: ProposalWhereInput
  isNot: ProposalWhereInput
}

enum ProposalScalarFieldEnum {
  accountId
  createdAt
  data
  estimatedOpGas
  feeToken
  gasLimit
  id
  nonce
  proposerId
  to
  value
}

enum ProposalState {
  Executed
  Executing
  Pending
}

input ProposalWhereInput {
  AND: [ProposalWhereInput!]
  NOT: [ProposalWhereInput!]
  OR: [ProposalWhereInput!]
  account: AccountRelationFilter
  accountId: StringFilter
  approvals: ApprovalListRelationFilter
  createdAt: DateTimeFilter
  data: StringNullableFilter
  estimatedOpGas: BigIntFilter
  feeToken: StringNullableFilter
  gasLimit: BigIntNullableFilter
  id: StringFilter
  nonce: BigIntFilter
  policyStates: PolicyStateListRelationFilter
  proposer: UserRelationFilter
  proposerId: StringFilter
  simulation: SimulationRelationFilter
  to: StringFilter
  transactions: TransactionListRelationFilter
  value: DecimalNullableFilter
}

input ProposalWhereUniqueInput {
  id: String
}

type Query {
  account(id: Address!): Account
  accounts(cursor: AccountWhereUniqueInput, distinct: [AccountScalarFieldEnum!], orderBy: [AccountOrderByWithRelationInput!], skip: Int, take: Int, where: AccountWhereInput): [Account!]!
  contact(addr: Address!): Contact
  contacts(cursor: ContactWhereUniqueInput, distinct: [ContactScalarFieldEnum!], orderBy: [ContactOrderByWithRelationInput!], skip: Int, take: Int): [Contact!]!
  contract(args: ContractInput!): Contract
  contractFunction(args: ContractFunctionInput!): ContractFunction
  policies(cursor: PolicyWhereUniqueInput, distinct: [PolicyScalarFieldEnum!], orderBy: [PolicyOrderByWithRelationInput!], skip: Int, take: Int, where: PolicyWhereInput): [Policy!]!
  policy(args: UniquePolicyInput!): Policy
  proposal(id: Bytes32!): Proposal
  proposals(accounts: [Address!], cursor: ProposalWhereUniqueInput, distinct: [ProposalScalarFieldEnum!], orderBy: [ProposalOrderByWithRelationInput!], skip: Int, states: [ProposalState!], take: Int, where: ProposalWhereInput): [Proposal!]!
  requestableTokens(account: Address!): [Address!]!
  transfers(input: TransfersInput!): [ExplorerTransfer!]!
  user(
    """Defaults to user"""
    id: Address
  ): User!
}

enum QueryMode {
  default
  insensitive
}

type Rejection {
  createdAt: DateTime!
  proposal: Proposal!
  proposalId: Bytes32!
  user: User!
  userId: Address!
}

type SatisfiablePolicy {
  id: String!
  key: PolicyKey!
  requiresUserAction: Boolean!
  satisfied: Boolean!
}

"""function selector (4-byte hex string)"""
scalar Selector

type SimulatedTransfer {
  amount: Decimal!
  from: Address!
  id: Float!
  proposalId: Bytes32!
  simulation: Simulation!
  to: Address!
  token: Address!
}

input SimulatedTransferListRelationFilter {
  every: SimulatedTransferWhereInput
  none: SimulatedTransferWhereInput
  some: SimulatedTransferWhereInput
}

input SimulatedTransferOrderByRelationAggregateInput {
  _count: SortOrder
}

input SimulatedTransferWhereInput {
  AND: [SimulatedTransferWhereInput!]
  NOT: [SimulatedTransferWhereInput!]
  OR: [SimulatedTransferWhereInput!]
  amount: DecimalFilter
  from: StringFilter
  id: IntFilter
  proposalId: StringFilter
  simulation: SimulationRelationFilter
  to: StringFilter
  token: StringFilter
}

type Simulation {
  proposal: Proposal!
  proposalId: Bytes32!
  transfers: [SimulatedTransfer!]
}

input SimulationOrderByWithRelationInput {
  proposal: ProposalOrderByWithRelationInput
  proposalId: SortOrder
  transfers: SimulatedTransferOrderByRelationAggregateInput
}

input SimulationRelationFilter {
  is: SimulationWhereInput
  isNot: SimulationWhereInput
}

input SimulationWhereInput {
  AND: [SimulationWhereInput!]
  NOT: [SimulationWhereInput!]
  OR: [SimulationWhereInput!]
  proposal: ProposalRelationFilter
  proposalId: StringFilter
  transfers: SimulatedTransferListRelationFilter
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

type Subscription {
  account(
    """Defaults to user accounts"""
    accounts: [Address!]

    """Defaults to all events"""
    events: AccountEvent
  ): Account!
  proposal(
    """Defaults to user accounts if no proposals are provided"""
    accounts: [Address!]

    """Defaults to all events"""
    events: [ProposalEvent!]
    proposals: [Bytes32!]
  ): Proposal!
}

type Target {
  selectors: [String!]!
  state: PolicyState!
  stateId: BigInt!
  to: String!
}

input TargetInput {
  """Functions that can be called on target (or *)"""
  selectors: [String!]!

  """Address of target (or *)"""
  to: String!
}

input TargetListRelationFilter {
  every: TargetWhereInput
  none: TargetWhereInput
  some: TargetWhereInput
}

input TargetOrderByRelationAggregateInput {
  _count: SortOrder
}

input TargetWhereInput {
  AND: [TargetWhereInput!]
  NOT: [TargetWhereInput!]
  OR: [TargetWhereInput!]
  selectors: StringNullableListFilter
  state: PolicyStateRelationFilter
  stateId: BigIntFilter
  to: StringFilter
}

type Transaction {
  createdAt: DateTime!
  gasLimit: Decimal!
  gasPrice: Decimal
  hash: Bytes32!

  """hash"""
  id: ID!
  proposal: Proposal!
  proposalId: Bytes32!
  receipt: TransactionReceipt
}

input TransactionListRelationFilter {
  every: TransactionWhereInput
  none: TransactionWhereInput
  some: TransactionWhereInput
}

input TransactionOrderByRelationAggregateInput {
  _count: SortOrder
}

type TransactionReceipt {
  blockNumber: Float!
  fee: Decimal!
  gasPrice: Decimal!
  gasUsed: Decimal!
  response: Bytes
  success: Boolean!
  timestamp: DateTime!
  transaction: Transaction!
  transactionHash: Bytes32!
  transfers: [Transfer!]
}

input TransactionReceiptRelationFilter {
  is: TransactionReceiptWhereInput
  isNot: TransactionReceiptWhereInput
}

input TransactionReceiptWhereInput {
  AND: [TransactionReceiptWhereInput!]
  NOT: [TransactionReceiptWhereInput!]
  OR: [TransactionReceiptWhereInput!]
  blockNumber: IntFilter
  fee: DecimalFilter
  gasPrice: DecimalFilter
  gasUsed: DecimalFilter
  response: StringNullableFilter
  success: BoolFilter
  timestamp: DateTimeFilter
  transaction: TransactionRelationFilter
  transactionHash: StringFilter
  transfers: TransferListRelationFilter
}

input TransactionRelationFilter {
  is: TransactionWhereInput
  isNot: TransactionWhereInput
}

input TransactionWhereInput {
  AND: [TransactionWhereInput!]
  NOT: [TransactionWhereInput!]
  OR: [TransactionWhereInput!]
  createdAt: DateTimeFilter
  gasLimit: DecimalFilter
  gasPrice: DecimalNullableFilter
  hash: StringFilter
  proposal: ProposalRelationFilter
  proposalId: StringFilter
  receipt: TransactionReceiptRelationFilter
}

type Transfer {
  account: Account!
  accountId: Address!
  amount: Decimal!
  blockNumber: Float!
  direction: TransferDirection!
  from: Address!
  id: Float!
  receipt: TransactionReceipt
  timestamp: DateTime!
  to: Address!
  token: Address!
  transactionHash: Bytes32
}

enum TransferDirection {
  IN
  OUT
}

input TransferListRelationFilter {
  every: TransferWhereInput
  none: TransferWhereInput
  some: TransferWhereInput
}

input TransferOrderByRelationAggregateInput {
  _count: SortOrder
}

input TransferWhereInput {
  AND: [TransferWhereInput!]
  NOT: [TransferWhereInput!]
  OR: [TransferWhereInput!]
  account: AccountRelationFilter
  accountId: StringFilter
  amount: DecimalFilter
  blockNumber: IntFilter
  direction: EnumTransferDirectionFilter
  from: StringFilter
  id: IntFilter
  receipt: TransactionReceiptRelationFilter
  timestamp: DateTimeFilter
  to: StringFilter
  token: StringFilter
  transactionHash: StringNullableFilter
}

input TransfersInput {
  account: Address!
  direction: TransferDirection
  skip: Float = 100
}

"""256-bit unsigned integer"""
scalar Uint256

input UniquePolicyInput {
  account: Address!
  key: PolicyKey!
}

input UpdateAccountInput {
  id: Address!
  name: String!
}

input UpdatePolicyInput {
  account: Address!

  """Signers that are required to approve"""
  approvers: [Address!]
  key: PolicyKey
  name: String
  permissions: PermissionsInput

  """Defaults to all approvers"""
  threshold: Float
}

type User {
  approvals: [Approval!]
  approvers: [Approver!]
  contacts: [Contact!]
  id: Address!
  name: String
  proposals: [Proposal!]
}

input UserOrderByWithRelationInput {
  approvals: ApprovalOrderByRelationAggregateInput
  approvers: ApproverOrderByRelationAggregateInput
  contacts: ContactOrderByRelationAggregateInput
  id: SortOrder
  name: SortOrder
  proposals: ProposalOrderByRelationAggregateInput
  pushToken: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  approvals: ApprovalListRelationFilter
  approvers: ApproverListRelationFilter
  contacts: ContactListRelationFilter
  id: StringFilter
  name: StringNullableFilter
  proposals: ProposalListRelationFilter
  pushToken: StringNullableFilter
}