# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

scalar AbiFunction @specifiedBy(url: "https://docs.soliditylang.org/en/latest/abi-spec.html#json")

enum AbiSource {
  Verified
}

enum AbiSourceConfidence {
  High
  Low
  Medium
}

type Account implements Node {
  address: UAddress!
  approvers: [Approver!]!
  chain: Chain!
  id: UUID!
  implementation: Address!
  isActive: Boolean!
  label: String!
  messages: [Message!]!
  name: String!
  photoUri: String
  policies: [Policy!]!
  proposals: [Proposal!]!
  salt: Bytes32!
  transactions: [Transaction!]!
  transfers: [Transfer!]!
  upgradedAtBlock: BigInt
}

enum AccountEvent {
  create
  update
}

input AccountInput {
  """Defaults to random user account"""
  account: UAddress
}

input AccountSubscriptionInput {
  """Defaults to user accounts"""
  accounts: [UAddress!]

  """Defaults to all events"""
  events: AccountEvent
}

type Action implements Node {
  allow: Boolean!
  description: String
  functions: [ActionFunction!]!
  id: UUID!
  label: String!
}

type ActionFunction implements Node {
  abi: AbiFunction

  """Default: apply to all contracts"""
  contract: Address
  id: UUID!

  """Default: apply to all selectors"""
  selector: Selector
}

input ActionFunctionInput {
  abi: AbiFunction

  """Default: apply to all contracts"""
  contract: Address

  """Default: apply to all selectors"""
  selector: Selector
}

input ActionInput {
  allow: Boolean!
  description: String
  functions: [ActionFunctionInput!]!
  label: String!
}

"""Ethereum address"""
scalar Address

type Approval implements Node & ProposalResponse {
  approver: Approver!
  createdAt: DateTime!
  id: UUID!
  invalid: Boolean!
  issues: [ApprovalIssue!]!
  proposal: Proposal!
}

enum ApprovalIssue {
  Expired
  HashMismatch
}

input ApproveInput {
  """Defaults to current approver"""
  approver: Address
  id: UUID!
  signature: Bytes!
}

type Approver implements Node {
  address: Address!
  id: UUID!
  label: String
}

input ApproverInput {
  """Defaults to current approver"""
  address: Address
}

input BalanceInput {
  account: UAddress
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

"""bytes hex string"""
scalar Bytes

"""32-byte hex string"""
scalar Bytes32

"""zksync | zksync-goerli | zksync-sepolia | zksync-local"""
scalar Chain

type Cloud {
  provider: CloudProvider!
  subject: String!
}

input CloudInput {
  provider: CloudProvider!
  subject: String!
}

enum CloudProvider {
  Apple
  Google
}

type Contact {
  address: UAddress!
  id: ID!
  label: String!
}

input ContactInput {
  address: UAddress!
}

input ContactsInput {
  query: String
}

type Contract {
  address: Address!
  functions: [ContractFunction!]!
  id: ID!
}

type ContractFunction {
  abi: JSON!
  abiMd5: String!
  id: ID!
  selector: Selector!
  source: AbiSource!
  sourceConfidence: AbiSourceConfidence!
}

input ContractFunctionInput {
  contract: Address!
  selector: Bytes!
}

input ContractInput {
  contract: Address!
}

input CreateAccountInput {
  chain: Chain
  label: String!
  policies: [PolicyInput!]!
}

input CreatePolicyInput {
  account: UAddress!
  actions: [ActionInput!]
  allowMessages: Boolean
  approvers: [Address!]

  """seconds"""
  delay: Float
  name: String
  threshold: Float
  transfers: TransfersConfigInput
}

union CreatePolicyResponse = NameTaken | Policy

interface CustomNode {
  id: ID!
}

type DappMetadata {
  icons: [URL!]!
  name: String!
  url: URL!
}

input DappMetadataInput {
  icons: [URL!]!
  name: String!
  url: URL!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

"""Decimal"""
scalar Decimal

interface Err {
  message: String!
}

input EstimateFeesPerGasInput {
  feeToken: UAddress!
}

type EstimatedTransactionFees implements CustomNode {
  ethCreditUsed: Decimal!
  id: ID!
  maxNetworkEthFee: Decimal!
  paymasterEthFees: PaymasterFees!
}

interface Event implements Node {
  block: BigInt!
  id: UUID!
  logIndex: Float!
  systxHash: Bytes32!
  timestamp: DateTime!
}

input ExecuteTransactionInput {
  id: UUID!
  ignoreSimulation: Boolean
}

type Failed implements Node & ReceiptResult & Result {
  block: BigInt!
  ethFeePerGas: Decimal!
  events: [Event!]!
  gasUsed: BigInt!
  id: UUID!
  reason: Bytes!
  timestamp: DateTime!
  transferApprovals: [TransferApproval!]!
  transfers: [Transfer!]!
}

type FeesPerGas implements CustomNode {
  feeTokenDecimals: Float!
  id: ID!
  maxFeePerGas: Decimal!
  maxPriorityFeePerGas: Decimal!
}

type GenericOp {
  _args: [JSON!]!
  _name: String!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input LabelAvailableInput {
  label: String!
}

input LabelInput {
  address: UAddress!
}

input LinkInput {
  token: String!
}

"""
A field whose value is a IEEE 802 48-bit MAC address: https://en.wikipedia.org/wiki/MAC_address.
"""
scalar MAC

type Message implements Node & Proposal {
  account: Account!
  approvals: [Approval!]!
  createdAt: DateTime!
  dapp: DappMetadata
  hash: Bytes32!
  iconUri: String
  id: UUID!
  label: String
  message: String!
  policy: Policy
  potentialApprovers: [Approver!]!
  potentialRejectors: [Approver!]!
  proposedBy: Approver!
  rejections: [Rejection!]!
  signature: Bytes32
  signedHash: Bytes32!
  typedData: TypedData
  updatable: Boolean!
  validFrom: DateTime!
}

type Mutation {
  approveMessage(input: ApproveInput!): Message!
  approveTransaction(input: ApproveInput!): Transaction!
  createAccount(input: CreateAccountInput!): Account!
  createPolicy(input: CreatePolicyInput!): CreatePolicyResponse!
  deleteContact(input: ContactInput!): ID
  execute(input: ExecuteTransactionInput!): Transaction
  link(input: LinkInput!): User!
  proposeCancelScheduledTransaction(input: ProposeCancelScheduledTransactionInput!): Transaction!
  proposeMessage(input: ProposeMessageInput!): Message!
  proposeTransaction(input: ProposeTransactionInput!): Transaction!
  rejectProposal(input: UniqueProposalInput!): Proposal!
  removeMessage(input: UniqueProposalInput!): ID!
  removePolicy(input: UniquePolicyInput!): Policy!
  removeToken(input: TokenInput!): ID
  removeTransaction(input: UniqueProposalInput!): ID
  requestTokens(input: RequestTokensInput!): [Address!]!
  updateAccount(input: UpdateAccountInput!): Account!
  updateApprover(input: UpdateApproverInput!): UserApprover!
  updatePolicy(input: UpdatePolicyInput!): UpdatePolicyResponse!
  updateProposal(input: UpdateProposalInput!): Proposal!
  updateTransaction(input: UpdateTransactionInput!): Transaction!
  updateUser(input: UpdateUserInput!): User!
  upsertContact(input: UpsertContactInput!): Contact!
  upsertToken(input: UpsertTokenInput!): Token!
}

type NameTaken implements Err {
  message: String!
}

interface Node {
  id: UUID!
}

type Operation {
  data: Bytes
  function: OperationFunction
  to: Address!
  value: Uint256
}

union OperationFunction = GenericOp | RemovePolicyOp | SwapOp | TransferApprovalOp | TransferFromOp | TransferOp | UpdatePolicyOp

input OperationInput {
  data: Bytes
  to: Address!
  value: Uint256
}

type PaymasterFees {
  activation: Decimal!
  total: Decimal!
}

input PoliciesInput {
  includeDisabled: Boolean! = false
}

type Policy {
  account: Account!
  draft: PolicyState
  id: ID!
  isActive: Boolean!
  key: PolicyKey!
  name: String!
  satisfiability(input: SatisfiabilityInput!): SatisfiabilityResult!
  state: PolicyState
  stateHistory: [PolicyState!]!
  stateOrDraft: PolicyState!
}

input PolicyInput {
  actions: [ActionInput!]
  allowMessages: Boolean
  approvers: [Address!]

  """seconds"""
  delay: Float
  name: String
  threshold: Float
  transfers: TransfersConfigInput
}

"""Policy key: an unsigned integer [0, 65535]"""
scalar PolicyKey

type PolicyState {
  actions: [Action!]!
  activationBlock: BigInt
  allowMessages: Boolean!
  approvers: [Approver!]!
  createdAt: DateTime!

  """seconds"""
  delay: Float!
  hasBeenActive: Boolean!
  id: ID!
  isAccountInitState: Boolean!
  isActive: Boolean!
  isRemoved: Boolean!
  proposal: Transaction
  threshold: Float!
  transfers: TransfersConfig!
}

type Price implements CustomNode {
  eth: Decimal!
  ethEma: Decimal!

  """Pyth USD price id"""
  id: ID!
  usd: Decimal!
  usdEma: Decimal!
}

interface Proposal implements Node {
  account: Account!
  approvals: [Approval!]!
  createdAt: DateTime!
  dapp: DappMetadata
  hash: Bytes32!
  iconUri: String
  id: UUID!
  label: String
  policy: Policy
  potentialApprovers: [Approver!]!
  potentialRejectors: [Approver!]!
  proposedBy: Approver!
  rejections: [Rejection!]!
  validFrom: DateTime!
}

enum ProposalEvent {
  approval
  approved
  cancelled
  create
  delete
  executed
  rejection
  scheduled
  submitted
  update
}

interface ProposalResponse implements Node {
  approver: Approver!
  createdAt: DateTime!
  id: UUID!
  proposal: Proposal!
}

input ProposalSubscriptionInput {
  """Defaults to user accounts if no proposals are provided"""
  accounts: [UAddress!]

  """Defaults to all events"""
  events: [ProposalEvent!]
  proposals: [UUID!]
}

input ProposalsInput {
  accounts: [UAddress!]
  pending: Boolean
}

input ProposeCancelScheduledTransactionInput {
  account: UAddress!
  dapp: DappMetadataInput
  feeToken: Address
  gas: Uint256
  iconUri: String
  label: String
  proposal: UUID!

  """Approve the proposal"""
  signature: Bytes
  validFrom: DateTime
}

input ProposeMessageInput {
  account: UAddress!
  dapp: DappMetadataInput
  iconUri: String
  label: String

  """Optional if typedData is provided"""
  message: String

  """Approve the proposal"""
  signature: Bytes
  typedData: TypedData
  validFrom: DateTime
}

input ProposeTransactionInput {
  account: UAddress!
  dapp: DappMetadataInput
  feeToken: Address
  gas: Uint256
  iconUri: String
  label: String
  operations: [OperationInput!]!

  """Approve the proposal"""
  signature: Bytes
  validFrom: DateTime
}

type Query {
  account(input: AccountInput! = {}): Account
  accounts: [Account!]!
  approver(input: ApproverInput! = {}): UserApprover
  contact(input: ContactInput!): Contact
  contacts(input: ContactsInput! = {}): [Contact!]!
  contract(input: ContractInput!): Contract
  contractFunction(input: ContractFunctionInput!): ContractFunction
  estimateFeesPerGas(input: EstimateFeesPerGasInput!): FeesPerGas
  label(input: LabelInput!): String
  labelAvailable(input: LabelAvailableInput!): Boolean!
  message(input: UniqueProposalInput!): Message
  policies(input: PoliciesInput! = {}): [Policy!]!
  policy(input: UniquePolicyInput!): Policy
  proposal(input: UniqueProposalInput!): Proposal
  proposals(input: ProposalsInput! = {}): [Proposal!]!
  requestableTokens(input: RequestTokensInput!): [Address!]!
  token(input: TokenInput!): Token
  tokenMetadata(input: TokenInput!): TokenMetadata!
  tokens(input: TokensInput! = {}): [Token!]!
  transaction(input: UniqueProposalInput!): Transaction
  transactions(input: TransactionsInput!): [Transaction!]!
  transfers(input: TransfersInput! = {}): [Transfer!]!
  user: User!
}

interface ReceiptResult implements Node & Result {
  block: BigInt!
  ethFeePerGas: Decimal!
  events: [Event!]!
  gasUsed: BigInt!
  id: UUID!
  timestamp: DateTime!
  transferApprovals: [TransferApproval!]!
  transfers: [Transfer!]!
}

type Rejection implements Node & ProposalResponse {
  approver: Approver!
  createdAt: DateTime!
  id: UUID!
  proposal: Proposal!
}

type RemovePolicyOp {
  _args: [JSON!]!
  _name: String!
  account: Address!
  key: PolicyKey!
}

input RequestTokensInput {
  account: UAddress!
}

interface Result implements Node {
  events: [Event!]!
  id: UUID!
  timestamp: DateTime!
  transferApprovals: [TransferApproval!]!
  transfers: [Transfer!]!
}

enum Satisfiability {
  satisfiable
  satisfied
  unsatisfiable
}

input SatisfiabilityInput {
  proposal: UUID!
}

type SatisfiabilityReason {
  operation: Float
  reason: String!
}

type SatisfiabilityResult {
  reasons: [SatisfiabilityReason!]!
  result: Satisfiability!
}

type Scheduled implements Node & Result {
  cancelled: Boolean!
  events: [Event!]!
  id: UUID!
  scheduledFor: DateTime!
  timestamp: DateTime!
  transferApprovals: [TransferApproval!]!
  transfers: [Transfer!]!
}

"""function selector (4-byte hex string)"""
scalar Selector

type SimulatedTransfer implements Node & TransferDetails {
  account: Account!
  amount: Decimal!
  direction: [TransferDirection!]!
  from: Address!
  id: UUID!
  isFeeTransfer: Boolean!
  to: Address!
  token: Token
  tokenAddress: UAddress!
  value: Decimal
}

type Simulation implements Node {
  id: UUID!
  responses: [Bytes!]!
  success: Boolean!
  timestamp: DateTime!
  transfers: [SimulatedTransfer!]!
}

type Subscription {
  account(input: AccountSubscriptionInput! = {}): Account!
  proposal(input: ProposalSubscriptionInput! = {}): Proposal!
  transfer(input: TransferSubscriptionInput! = {}): Transfer!
  user: User!
}

type Successful implements Node & ReceiptResult & Result {
  block: BigInt!
  ethFeePerGas: Decimal!
  events: [Event!]!
  gasUsed: BigInt!
  id: UUID!
  responses: [Bytes!]!
  timestamp: DateTime!
  transferApprovals: [TransferApproval!]!
  transfers: [Transfer!]!
}

type SwapOp {
  _args: [JSON!]!
  _name: String!
  deadline: DateTime!
  fromAmount: Decimal!
  fromToken: Address!
  minimumToAmount: Decimal!
  toToken: Address!
}

type SystemTx implements Node {
  ethCreditUsed: Decimal!
  ethPerFeeToken: Decimal!
  hash: Bytes32!
  id: UUID!
  maxEthFeePerGas: Decimal!
  maxEthFees: Decimal!
  maxNetworkEthFee: Decimal!
  paymasterEthFees: PaymasterFees!
  proposal: Transaction!
  receipt: Result
  timestamp: DateTime!
  usdPerFeeToken: Decimal!
}

type Token implements Node {
  address: UAddress!
  balance(input: BalanceInput!): Decimal!
  decimals: Int!
  estimatedFeesPerGas: FeesPerGas
  iconUri: String
  id: UUID!
  isFeeToken: Boolean!
  name: String!
  price: Price
  pythUsdPriceId: Bytes32
  removable: Boolean!
  symbol: String!
  units: [TokenUnit!]
  userOwned: Boolean!
}

input TokenInput {
  address: UAddress!
}

type TokenMetadata {
  decimals: Int
  iconUri: String
  id: ID!
  name: String
  pythUsdPriceId: Bytes32
  symbol: String
}

type TokenUnit {
  decimals: Int!
  symbol: String!
}

input TokenUnitInput {
  decimals: Int!
  symbol: String!
}

input TokensInput {
  address: [UAddress!]
  chain: Chain
  feeToken: Boolean
  query: String
}

type Transaction implements Node & Proposal {
  account: Account!
  approvals: [Approval!]!
  createdAt: DateTime!
  dapp: DappMetadata
  estimatedFees: EstimatedTransactionFees!
  feeToken: Token!
  gasLimit: BigInt!
  hash: Bytes32!
  iconUri: String
  id: UUID!
  label: String
  maxPaymasterEthFees: PaymasterFees!
  nonce: BigInt!
  operations: [Operation!]!
  paymaster: Address!
  policy: Policy
  potentialApprovers: [Approver!]!
  potentialRejectors: [Approver!]!
  proposedBy: Approver!
  rejections: [Rejection!]!
  result: Result
  results: [Result!]!
  simulation: Simulation
  status: TransactionStatus!
  submitted: Boolean!
  systx: SystemTx
  systxs: [SystemTx!]!
  updatable: Boolean!
  validFrom: DateTime!
}

enum TransactionStatus {
  Cancelled
  Executing
  Failed
  Pending
  Scheduled
  Successful
}

input TransactionsInput {
  accounts: [UAddress!]
  statuses: [TransactionStatus!]
}

type Transfer implements Event & Node & TransferDetails & Transferlike {
  account: Account!
  amount: Decimal!
  block: BigInt!
  direction: [TransferDirection!]!
  from: Address!
  id: UUID!
  isFeeTransfer: Boolean!
  logIndex: Float!
  systxHash: Bytes32!
  timestamp: DateTime!
  to: Address!
  token: Token
  tokenAddress: UAddress!
  value: Decimal
}

type TransferApproval implements Event & Node & TransferDetails & Transferlike {
  account: Account!
  amount: Decimal!
  block: BigInt!
  delta: Decimal!
  direction: [TransferDirection!]!
  from: Address!
  id: UUID!
  isFeeTransfer: Boolean!
  logIndex: Float!
  systxHash: Bytes32!
  timestamp: DateTime!
  to: Address!
  token: Token
  tokenAddress: UAddress!
  value: Decimal
}

type TransferApprovalOp implements TransferlikeOp {
  amount: Decimal!
  spender: Address!
  token: Address!
}

interface TransferDetails implements Node {
  account: Account!
  amount: Decimal!
  direction: [TransferDirection!]!
  from: Address!
  id: UUID!
  isFeeTransfer: Boolean!
  to: Address!
  token: Token
  tokenAddress: UAddress!
  value: Decimal
}

enum TransferDirection {
  In
  Out
}

type TransferFromOp implements TransferlikeOp {
  amount: Decimal!
  from: Address!
  to: Address!
  token: Address!
}

type TransferLimit {
  amount: BigInt!

  """seconds"""
  duration: Float!
  id: ID!
  token: Address!
}

input TransferLimitInput {
  amount: BigInt!

  """seconds"""
  duration: Float!
  token: Address!
}

type TransferOp implements TransferlikeOp {
  amount: Decimal!
  to: Address!
  token: Address!
}

input TransferSubscriptionInput {
  accounts: [UAddress!]
  direction: TransferDirection

  """Originating from an account transaction"""
  internal: Boolean
}

interface Transferlike implements Event & Node & TransferDetails {
  account: Account!
  amount: Decimal!
  block: BigInt!
  direction: [TransferDirection!]!
  from: Address!
  id: UUID!
  isFeeTransfer: Boolean!
  logIndex: Float!
  systxHash: Bytes32!
  timestamp: DateTime!
  to: Address!
  token: Token
  tokenAddress: UAddress!
  value: Decimal
}

interface TransferlikeOp {
  amount: Decimal!
  token: Address!
}

type TransfersConfig {
  budget: Float!
  defaultAllow: Boolean!
  id: ID!
  limits: [TransferLimit!]!
}

input TransfersConfigInput {
  """Defaults to the policy budget"""
  budget: Float
  defaultAllow: Boolean! = true
  limits: [TransferLimitInput!]! = []
}

input TransfersInput {
  accounts: [UAddress!]
  direction: TransferDirection

  """Originating from an account transaction"""
  internal: Boolean
}

"""EIP712 Typed Data"""
scalar TypedData

"""EIP-3770 address"""
scalar UAddress @specifiedBy(url: "https://eips.ethereum.org/EIPS/eip-3770")

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

"""UUID"""
scalar UUID @specifiedBy(url: "https://en.wikipedia.org/wiki/Universally_unique_identifier")

"""256-bit unsigned integer"""
scalar Uint256

input UniquePolicyInput {
  account: UAddress!
  key: PolicyKey!
}

input UniqueProposalInput {
  id: UUID!
}

input UpdateAccountInput {
  account: UAddress!
  label: String!
  photoUri: URL
}

input UpdateApproverInput {
  """Defaults to current approver"""
  address: Address
  bluetoothDevices: [MAC!]
  cloud: CloudInput
  name: String
  pushToken: String
}

input UpdatePolicyInput {
  account: UAddress!
  actions: [ActionInput!]
  allowMessages: Boolean
  approvers: [Address!]

  """seconds"""
  delay: Float
  key: PolicyKey!
  name: String
  threshold: Float
  transfers: TransfersConfigInput
}

type UpdatePolicyOp {
  _args: [JSON!]!
  _name: String!
  account: Address!
  approvers: [Address!]!
  key: PolicyKey!
  threshold: Float!
}

union UpdatePolicyResponse = NameTaken | Policy

input UpdateProposalInput {
  id: UUID!
  policy: PolicyKey
}

input UpdateTransactionInput {
  feeToken: Address
  id: UUID!
  policy: PolicyKey
}

input UpdateUserInput {
  primaryAccount: UAddress
}

input UpsertContactInput {
  address: UAddress!
  label: String!
  previousAddress: UAddress
}

input UpsertTokenInput {
  address: UAddress!
  decimals: Int
  iconUri: String
  name: String
  pythUsdPriceId: Bytes32
  symbol: String
  units: [TokenUnitInput!]! = []
}

type User implements Node {
  approvers: [UserApprover!]!
  contacts: [Contact!]!
  id: UUID!
  linkingToken: String!
  primaryAccount: Account
}

type UserApprover implements Node {
  address: Address!
  bluetoothDevices: [MAC!]
  cloud: Cloud
  id: UUID!
  label: String
  name: String
  pushToken: String
}