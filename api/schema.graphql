# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

enum AbiSource {
  Verified
}

enum AbiSourceConfidence {
  High
  Low
  Medium
}

type Account {
  address: Address!
  id: ID!
  implementation: Address!
  isActive: Boolean!
  name: String
  policies: [Policy!]!
  proposals: [Proposal!]!
  salt: Bytes32!
  transactionProposals: [TransactionProposal!]!
  transfers: [Transfer!]!
}

enum AccountEvent {
  create
  update
}

input AccountInput {
  address: Address!
}

input AccountSubscriptionInput {
  """Defaults to user accounts"""
  accounts: [Address!]

  """Defaults to all events"""
  events: AccountEvent
}

type AddPolicyOp {
  _args: [JSON!]!
  _name: String!
  account: Address!
  approvers: [Address!]!
  key: PolicyKey!
  targets: [Target!]!
  threshold: Float!
}

"""Ethereum address"""
scalar Address

type Approval {
  createdAt: DateTime!
  id: ID!
  proposal: Proposal!
  user: User!
}

input ApproveInput {
  hash: Bytes32!
  signature: Bytes!
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

"""bytes hex string"""
scalar Bytes

"""32-byte hex string"""
scalar Bytes32

type Contact {
  address: Address!
  id: ID!
  name: String!
}

input ContactInput {
  address: Address!
}

type Contract {
  address: Address!
  functions: [ContractFunction!]!
  id: ID!
}

type ContractFunction {
  abi: JSON!
  abiMd5: String!
  id: ID!
  selector: Selector!
  source: AbiSource!
  sourceConfidence: AbiSourceConfidence!
}

input ContractFunctionInput {
  contract: Address!
  selector: Bytes!
}

input ContractInput {
  contract: Address!
}

input CreateAccountInput {
  name: String!
  policies: [PolicyInput!]!
}

input CreatePolicyInput {
  account: Address!

  """Signers that are required to approve"""
  approvers: [Address!]
  key: PolicyKey
  name: String
  permissions: PermissionsInput!

  """Defaults to all approvers"""
  threshold: Float
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input ExecuteInput {
  proposalHash: Bytes32!
}

type GenericOp {
  _args: [JSON!]!
  _name: String!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Mutation {
  approve(input: ApproveInput!): TransactionProposal!
  createAccount(input: CreateAccountInput!): Account!
  createPolicy(input: CreatePolicyInput!): Policy!
  deleteContact(input: ContactInput!): ID
  execute(input: ExecuteInput!): Transaction
  propose(input: ProposeInput!): TransactionProposal!
  reject(input: ProposalInput!): TransactionProposal!
  removePolicy(input: UniquePolicyInput!): Policy!
  removeProposal(input: ProposalInput!): ID
  requestTokens(input: RequestTokensInput!): [Address!]!
  updateAccount(input: UpdateAccountInput!): Account!
  updatePolicy(input: UpdatePolicyInput!): Policy!
  updateProposal(input: UpdateProposalInput!): TransactionProposal!
  updateUser(input: UpdateUserInput!): User!
  upsertContact(input: UpsertContactInput!): Contact!
}

type Operation {
  data: Bytes
  function: OperationFunction
  to: Address!
  value: Uint256
}

union OperationFunction = AddPolicyOp | GenericOp | RemovePolicyOp | SwapOp | TransferApprovalOp | TransferFromOp | TransferOp

input OperationInput {
  data: Bytes
  to: Address!
  value: Uint256
}

input PermissionsInput {
  """Targets that can be called"""
  targets: [TargetInput!]
}

type Policy {
  account: Account!
  draft: PolicyState
  id: ID!
  isActive: Boolean!
  key: PolicyKey!
  name: String!
  state: PolicyState
  stateHistory: [PolicyState!]!
}

input PolicyInput {
  """Signers that are required to approve"""
  approvers: [Address!]
  key: PolicyKey
  name: String
  permissions: PermissionsInput!

  """Defaults to all approvers"""
  threshold: Float
}

"""Policy key: an unsigned integer [0, 65535]"""
scalar PolicyKey

type PolicyState {
  activationBlock: BigInt
  approvers: [User!]!
  createdAt: DateTime!
  id: ID!
  isAccountInitState: Boolean!
  isRemoved: Boolean!
  proposal: TransactionProposal
  targets: [Target!]!
  threshold: Float!
}

type Proposal {
  account: Account!
  approvals: [Approval!]!
  createdAt: DateTime!
  hash: Bytes32!
  id: ID!
  label: String
  policy: Policy
  proposedBy: User!
  rejections: [Rejection!]!
  responses: [ProposalResponse!]!
}

enum ProposalEvent {
  approval
  create
  delete
  executed
  rejection
  submitted
  update
}

input ProposalInput {
  hash: Bytes32!
}

type ProposalResponse {
  createdAt: DateTime!
  id: ID!
  proposal: Proposal!
  user: User!
}

input ProposalSubscriptionInput {
  """Defaults to user accounts if no proposals are provided"""
  accounts: [Address!]

  """Defaults to all events"""
  events: [ProposalEvent!]
  proposals: [Bytes32!]
}

input ProposalsInput {
  accounts: [Address!]
  statuses: [TransactionProposalStatus!]
}

input ProposeInput {
  account: Address!
  feeToken: Address
  gasLimit: Uint256
  label: String
  nonce: Uint256
  operations: [OperationInput!]!

  """Approve the proposal"""
  signature: Bytes
}

type Query {
  account(input: AccountInput!): Account
  accounts: [Account!]!
  contact(input: ContactInput!): Contact
  contacts: [Contact!]!
  contract(input: ContractInput!): Contract
  contractFunction(input: ContractFunctionInput!): ContractFunction
  paymaster: Address!
  policies: [Policy!]!
  policy(input: UniquePolicyInput!): Policy
  proposal(input: ProposalInput!): TransactionProposal
  proposals(input: ProposalsInput! = {}): [TransactionProposal!]!
  requestableTokens(input: RequestTokensInput!): [Address!]!
  transaction(input: TransactionInput!): Transaction
  transfers(input: TransfersInput! = {}): [Transfer!]!
  user(input: UserInput! = {}): User!
}

type Receipt {
  block: BigInt!
  fee: BigInt!
  gasUsed: BigInt!
  id: ID!
  responses: [Bytes!]!
  success: Boolean!
  timestamp: DateTime!
  transfers: [Transfer!]!
}

type Rejection {
  createdAt: DateTime!
  id: ID!
  proposal: Proposal!
  user: User!
}

type RemovePolicyOp {
  _args: [JSON!]!
  _name: String!
  account: Address!
  key: PolicyKey!
}

input RequestTokensInput {
  account: Address!
}

type SatisfiablePolicy {
  id: ID!
  key: PolicyKey!
  responseRequested: Boolean!
  satisfied: Boolean!
}

"""function selector (4-byte hex string)"""
scalar Selector

type Simulation {
  id: ID!
  transfers: [TransferDetails!]!
}

type Subscription {
  account(input: AccountSubscriptionInput! = {}): Account!
  proposal(input: ProposalSubscriptionInput! = {}): TransactionProposal!
  transfer(input: TransferSubscriptionInput! = {}): Transfer!
}

type SwapOp {
  _args: [JSON!]!
  _name: String!
  deadline: DateTime!
  fromAmount: Uint256!
  fromToken: Address!
  minimumToAmount: Uint256!
  toToken: Address!
}

type Target {
  id: ID!
  selectors: [String!]!
  to: String!
}

input TargetInput {
  """Functions that can be called on target (or *)"""
  selectors: [String!]!

  """Address of target (or *)"""
  to: String!
}

type Transaction {
  gasPrice: BigInt!
  hash: Bytes32!
  id: ID!
  proposal: TransactionProposal!
  receipt: Receipt
  submittedAt: DateTime!
}

input TransactionInput {
  hash: Bytes32!
}

type TransactionProposal {
  account: Account!
  approvals: [Approval!]!
  createdAt: DateTime!
  feeToken: Address!
  gasLimit: BigInt!
  hash: Bytes32!
  id: ID!
  label: String
  nonce: BigInt!
  operations: [Operation!]!
  policy: Policy
  proposedBy: User!
  rejections: [Rejection!]!
  responses: [ProposalResponse!]!
  satisfiablePolicies: [SatisfiablePolicy!]!
  simulation: Simulation!
  status: TransactionProposalStatus!
  transaction: Transaction
  transactions: [Transaction!]!
}

enum TransactionProposalStatus {
  Executing
  Failed
  Pending
  Successful
}

type Transfer {
  account: Account!
  amount: BigInt!
  block: BigInt!
  direction: TransferDirection!
  from: Address!
  id: ID!
  logIndex: Float!
  receipt: Receipt
  timestamp: DateTime!
  to: Address!
  token: Address!
}

type TransferApprovalOp {
  _args: [JSON!]!
  _name: String!
  amount: Uint256!
  spender: Address!
  token: Address!
}

type TransferDetails {
  account: Account!
  amount: BigInt!
  direction: TransferDirection!
  from: Address!
  id: ID!
  to: Address!
  token: Address!
}

enum TransferDirection {
  In
  Out
}

type TransferFromOp {
  _args: [JSON!]!
  _name: String!
  amount: Uint256!
  from: Address!
  to: Address!
  token: Address!
}

type TransferOp {
  _args: [JSON!]!
  _name: String!
  amount: Uint256!
  to: Address!
  token: Address!
}

input TransferSubscriptionInput {
  accounts: [Address!]
  directions: [TransferDirection!]
}

input TransfersInput {
  accounts: [Address!]
  direction: TransferDirection
  excludeProposalOriginating: Boolean
}

"""256-bit unsigned integer"""
scalar Uint256

input UniquePolicyInput {
  account: Address!
  key: PolicyKey!
}

input UpdateAccountInput {
  address: Address!
  name: String!
}

input UpdatePolicyInput {
  account: Address!

  """Signers that are required to approve"""
  approvers: [Address!]
  key: PolicyKey
  name: String
  permissions: PermissionsInput

  """Defaults to all approvers"""
  threshold: Float
}

input UpdateProposalInput {
  feeToken: Address
  hash: Bytes32!
  policy: PolicyKey
}

input UpdateUserInput {
  name: String
  pushToken: String
}

input UpsertContactInput {
  address: Address!
  name: String!
  previousAddress: Address
}

type User {
  address: Address!
  contacts: [Contact!]!
  id: ID!
  name: String
}

input UserInput {
  """Defaults to user"""
  address: Address
}