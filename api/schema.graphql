# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

enum AbiSource {
  Verified
}

enum AbiSourceConfidence {
  High
  Low
  Medium
}

type Account {
  address: Address!
  id: ID!
  implementation: Address!
  isActive: Boolean!
  name: String!
  policies: [Policy!]!
  proposals: [Proposal!]!
  salt: Bytes32!
  transactionProposals: [TransactionProposal!]!
  transfers: [Transfer!]!
}

enum AccountEvent {
  create
  update
}

input AccountInput {
  """Defaults to random user account"""
  address: Address
}

input AccountSubscriptionInput {
  """Defaults to user accounts"""
  accounts: [Address!]

  """Defaults to all events"""
  events: AccountEvent
}

type AddPolicyOp {
  _args: [JSON!]!
  _name: String!
  account: Address!
  approvers: [Address!]!
  key: PolicyKey!
  targets: [Target!]!
  threshold: Float!
}

"""Ethereum address"""
scalar Address

type Approval {
  approver: Approver!
  createdAt: DateTime!
  id: ID!
  proposal: Proposal!
}

input ApproveInput {
  hash: Bytes32!
  signature: Bytes!
}

type Approver {
  address: Address!
  id: ID!
  label: String
}

input ApproverInput {
  """Defaults to current approver"""
  address: Address
}

input BalanceInput {
  account: Address
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

"""bytes hex string"""
scalar Bytes

"""4-byte hex string"""
scalar Bytes4

"""32-byte hex string"""
scalar Bytes32

type Contact {
  address: Address!
  id: ID!
  label: String!
}

input ContactInput {
  address: Address!
}

input ContactsInput {
  query: String
}

type Contract {
  address: Address!
  functions: [ContractFunction!]!
  id: ID!
}

type ContractFunction {
  abi: JSON!
  abiMd5: String!
  id: ID!
  selector: Selector!
  source: AbiSource!
  sourceConfidence: AbiSourceConfidence!
}

input ContractFunctionInput {
  contract: Address!
  selector: Bytes!
}

input ContractInput {
  contract: Address!
}

type ContractTarget {
  contract: Address!
  defaultAllow: Boolean!
  functions: [FunctionConfig!]!
  id: ID!
}

input ContractTargetInput {
  contract: Address!
  defaultAllow: Boolean! = true
  functions: [SelectorInput!]! = []
}

input CreateAccountInput {
  name: String!
  policies: [PolicyInput!]!
}

input CreatePolicyInput {
  account: Address!

  """Signers that are required to approve"""
  approvers: [Address!]
  key: PolicyKey
  name: String
  permissions: PermissionsInput! = {}

  """Defaults to all approvers"""
  threshold: Float
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

union Event = Transfer | TransferApproval

interface EventBase {
  account: Account!
  block: BigInt!
  id: ID!
  logIndex: Float!
  timestamp: DateTime!
}

input ExecuteInput {
  proposalHash: Bytes32!
}

type FunctionConfig {
  allow: Boolean!
  selector: Bytes4!
}

type GenericOp {
  _args: [JSON!]!
  _name: String!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input LabelInput {
  address: Address!
}

type Mutation {
  approve(input: ApproveInput!): TransactionProposal!
  createAccount(input: CreateAccountInput!): Account!
  createPolicy(input: CreatePolicyInput!): Policy!
  deleteContact(input: ContactInput!): ID
  execute(input: ExecuteInput!): Transaction

  """Pair with another user - merging your approvers"""
  pair(input: PairInput!): User!
  propose(input: ProposeInput!): TransactionProposal!
  reject(input: ProposalInput!): TransactionProposal!
  removePolicy(input: UniquePolicyInput!): Policy!
  removeProposal(input: ProposalInput!): ID
  removeToken(input: TokenInput!): ID
  requestTokens(input: RequestTokensInput!): [Address!]!
  updateAccount(input: UpdateAccountInput!): Account!
  updateApprover(input: UpdateApproverInput!): UserApprover!
  updatePolicy(input: UpdatePolicyInput!): Policy!
  updateProposal(input: UpdateProposalInput!): TransactionProposal!
  updateUser(input: UpdateUserInput!): User!
  upsertContact(input: UpsertContactInput!): Contact!
  upsertToken(input: UpsertTokenInput!): Token!
}

interface Node {
  id: ID!
}

type Operation {
  data: Bytes
  function: OperationFunction
  to: Address!
  value: Uint256
}

union OperationFunction = AddPolicyOp | GenericOp | RemovePolicyOp | SwapOp | TransferApprovalOp | TransferFromOp | TransferOp

input OperationInput {
  data: Bytes
  to: Address!
  value: Uint256
}

input PairInput {
  token: String!
}

input PermissionsInput {
  """Targets that can be called"""
  targets: TargetsConfigInput
  transfers: TransfersConfigInput
}

type Policy {
  account: Account!
  draft: PolicyState
  id: ID!
  isActive: Boolean!
  key: PolicyKey!
  name: String!
  satisfiability(input: SatisfiabilityInput!): SatisfiabilityResult!
  state: PolicyState
  stateHistory: [PolicyState!]!
}

input PolicyInput {
  """Signers that are required to approve"""
  approvers: [Address!]
  key: PolicyKey
  name: String
  permissions: PermissionsInput! = {}

  """Defaults to all approvers"""
  threshold: Float
}

"""Policy key: an unsigned integer [0, 65535]"""
scalar PolicyKey

type PolicyState {
  activationBlock: BigInt
  approvers: [Approver!]!
  createdAt: DateTime!
  id: ID!
  isAccountInitState: Boolean!
  isRemoved: Boolean!
  proposal: TransactionProposal
  targets: TargetsConfig!
  threshold: Float!
  transfers: TransfersConfig!
}

type Price {
  current: Float!
  id: ID!
  token: Address!
}

type Proposal {
  account: Account!
  approvals: [Approval!]!
  createdAt: DateTime!
  hash: Bytes32!
  id: ID!
  label: String
  policy: Policy
  proposedBy: Approver!
  rejections: [Rejection!]!
  responses: [ProposalResponse!]!
}

enum ProposalEvent {
  approval
  create
  delete
  executed
  rejection
  submitted
  update
}

input ProposalInput {
  hash: Bytes32!
}

type ProposalResponse {
  approver: Approver!
  createdAt: DateTime!
  id: ID!
  proposal: Proposal!
}

input ProposalSubscriptionInput {
  """Defaults to user accounts if no proposals are provided"""
  accounts: [Address!]

  """Defaults to all events"""
  events: [ProposalEvent!]
  proposals: [Bytes32!]
}

input ProposalsInput {
  accounts: [Address!]
  statuses: [TransactionProposalStatus!]
}

input ProposeInput {
  account: Address!
  feeToken: Address
  gasLimit: Uint256
  label: String
  nonce: Uint256
  operations: [OperationInput!]!

  """Approve the proposal"""
  signature: Bytes
}

type Query {
  account(input: AccountInput! = {}): Account
  accounts: [Account!]!
  approver(input: ApproverInput! = {}): UserApprover!
  contact(input: ContactInput!): Contact
  contacts(input: ContactsInput! = {}): [Contact!]!
  contract(input: ContractInput!): Contract
  contractFunction(input: ContractFunctionInput!): ContractFunction
  label(input: LabelInput!): String
  paymaster: Address!
  policies: [Policy!]!
  policy(input: UniquePolicyInput!): Policy
  proposal(input: ProposalInput!): TransactionProposal
  proposals(input: ProposalsInput! = {}): [TransactionProposal!]!
  requestableTokens(input: RequestTokensInput!): [Address!]!
  token(input: TokenInput!): Token
  tokens(input: TokensInput! = {}): [Token!]!
  transaction(input: TransactionInput!): Transaction
  transfers(input: TransfersInput! = {}): [Transfer!]!
  user: User!
}

type Receipt {
  block: BigInt!
  events: [Event!]!
  fee: BigInt!
  gasUsed: BigInt!
  id: ID!
  responses: [Bytes!]!
  success: Boolean!
  timestamp: DateTime!
  transferApprovalEvents: [TransferApproval!]!
  transferEvents: [Transfer!]!
}

type Rejection {
  approver: Approver!
  createdAt: DateTime!
  id: ID!
  proposal: Proposal!
}

type RemovePolicyOp {
  _args: [JSON!]!
  _name: String!
  account: Address!
  key: PolicyKey!
}

input RequestTokensInput {
  account: Address!
}

enum Satisfiability {
  satisfiable
  satisfied
  unsatisfiable
}

input SatisfiabilityInput {
  proposal: Bytes32!
}

type SatisfiabilityReason {
  operation: Float
  reason: String!
}

type SatisfiabilityResult {
  reasons: [SatisfiabilityReason!]!
  result: Satisfiability!
}

"""function selector (4-byte hex string)"""
scalar Selector

input SelectorInput {
  allow: Boolean!
  selector: Bytes4!
}

type Simulation {
  id: ID!
  transfers: [SimulationTransfer!]!
}

type SimulationTransfer implements TransferDetails {
  account: Account!
  amount: BigInt!
  direction: TransferDirection!
  from: Address!
  id: ID!
  to: Address!
  token: Token
  tokenAddress: Address!
  value: Float
}

type Subscription {
  account(input: AccountSubscriptionInput! = {}): Account!
  proposal(input: ProposalSubscriptionInput! = {}): TransactionProposal!
  transfer(input: TransferSubscriptionInput! = {}): Transfer!
  user: User!
}

type SwapOp {
  _args: [JSON!]!
  _name: String!
  deadline: DateTime!
  fromAmount: Uint256!
  fromToken: Address!
  minimumToAmount: Uint256!
  toToken: Address!
}

type Target {
  defaultAllow: Boolean!
  functions: [FunctionConfig!]!
  id: ID!
}

input TargetInput {
  defaultAllow: Boolean! = true
  functions: [SelectorInput!]! = []
}

type TargetsConfig {
  contracts: [ContractTarget!]!
  default: Target!
  id: ID!
}

input TargetsConfigInput {
  contracts: [ContractTargetInput!]! = []
  default: TargetInput! = {defaultAllow: true, functions: []}
}

type Token implements Node {
  address: Address!
  balance(input: BalanceInput!): BigInt!
  decimals: Float!
  ethereumAddress: Address
  iconUri: String
  id: ID!
  name: String!
  price: Price
  symbol: String!
  units: [TokenUnit!]
}

input TokenInput {
  address: Address!
}

type TokenUnit {
  decimals: Float!
  symbol: String!
}

input TokenUnitInput {
  decimals: Float!
  symbol: String!
}

input TokensInput {
  query: String
}

type Transaction {
  gasPrice: BigInt!
  hash: Bytes32!
  id: ID!
  proposal: TransactionProposal!
  receipt: Receipt
  submittedAt: DateTime!
}

input TransactionInput {
  hash: Bytes32!
}

type TransactionProposal {
  account: Account!
  approvals: [Approval!]!
  createdAt: DateTime!
  feeToken: Address!
  gasLimit: BigInt!
  hash: Bytes32!
  id: ID!
  label: String
  nonce: BigInt!
  operations: [Operation!]!
  policy: Policy
  proposedBy: Approver!
  rejections: [Rejection!]!
  responses: [ProposalResponse!]!
  simulation: Simulation!
  status: TransactionProposalStatus!
  transaction: Transaction
  transactions: [Transaction!]!
  updatable: Boolean!
}

enum TransactionProposalStatus {
  Executing
  Failed
  Pending
  Successful
}

type Transfer implements EventBase & TransferDetails & Transferlike {
  account: Account!
  amount: BigInt!
  block: BigInt!
  direction: TransferDirection!
  from: Address!
  id: ID!
  logIndex: Float!
  timestamp: DateTime!
  to: Address!
  token: Token
  tokenAddress: Address!
  value: Float
}

type TransferApproval implements EventBase & TransferDetails & Transferlike {
  account: Account!
  amount: BigInt!
  block: BigInt!
  delta: BigInt!
  direction: TransferDirection!
  from: Address!
  id: ID!
  logIndex: Float!
  timestamp: DateTime!
  to: Address!
  token: Token
  tokenAddress: Address!
  value: Float
}

type TransferApprovalOp {
  _args: [JSON!]!
  _name: String!
  amount: Uint256!
  spender: Address!
  token: Address!
}

interface TransferDetails {
  account: Account!
  amount: BigInt!
  direction: TransferDirection!
  from: Address!
  id: ID!
  to: Address!
  token: Token
  tokenAddress: Address!
  value: Float
}

enum TransferDirection {
  In
  Out
}

type TransferFromOp {
  _args: [JSON!]!
  _name: String!
  amount: Uint256!
  from: Address!
  to: Address!
  token: Address!
}

type TransferLimit {
  amount: BigInt!

  """seconds"""
  duration: Float!
  id: ID!
  token: Address!
}

input TransferLimitInput {
  amount: BigInt!

  """seconds"""
  duration: Float!
  token: Address!
}

type TransferOp {
  _args: [JSON!]!
  _name: String!
  amount: Uint256!
  to: Address!
  token: Address!
}

input TransferSubscriptionInput {
  accounts: [Address!]
  directions: [TransferDirection!]

  """Not originating from an account transaction"""
  external: Boolean
}

interface Transferlike implements EventBase & TransferDetails {
  account: Account!
  amount: BigInt!
  block: BigInt!
  direction: TransferDirection!
  from: Address!
  id: ID!
  logIndex: Float!
  timestamp: DateTime!
  to: Address!
  token: Token
  tokenAddress: Address!
  value: Float
}

type TransfersConfig {
  budget: Float!
  defaultAllow: Boolean!
  id: ID!
  limits: [TransferLimit!]!
}

input TransfersConfigInput {
  """Defaults to the policy budget"""
  budget: Float
  defaultAllow: Boolean! = true
  limits: [TransferLimitInput!]! = []
}

input TransfersInput {
  accounts: [Address!]
  direction: TransferDirection

  """Not originating from an account transaction"""
  external: Boolean
}

"""256-bit unsigned integer"""
scalar Uint256

input UniquePolicyInput {
  account: Address!
  key: PolicyKey!
}

input UpdateAccountInput {
  address: Address!
  name: String!
}

input UpdateApproverInput {
  """Defaults to current approver"""
  address: Address
  name: String
  pushToken: String
}

input UpdatePolicyInput {
  account: Address!

  """Signers that are required to approve"""
  approvers: [Address!]
  key: PolicyKey
  name: String
  permissions: PermissionsInput = {}

  """Defaults to all approvers"""
  threshold: Float
}

input UpdateProposalInput {
  feeToken: Address
  hash: Bytes32!
  policy: PolicyKey
}

input UpdateUserInput {
  name: String
}

input UpsertContactInput {
  address: Address!
  label: String!
  previousAddress: Address
}

input UpsertTokenInput {
  address: Address!
  decimals: Float!
  ethereumAddress: Address
  iconUri: String
  name: String!
  symbol: String!
  units: [TokenUnitInput!]! = []
}

type User {
  approvers: [UserApprover!]!
  contacts: [Contact!]!
  id: ID!
  name: String
  pairingToken: String!
}

type UserApprover {
  address: Address!
  id: ID!
  label: String
  name: String
  pushToken: String
}